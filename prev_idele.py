r"""
Idele Groups of Number Fields

Before introducing idèles and their representations, consider the real interval
field ``RIF``. ``RIF`` allows us to compute with *arbitrary* real numbers, even
though storing a single real number requires an infinite amount of information
in general. A ``RealIntervalFieldElement`` `I` consists of a pair of floating
point numbers `I = (x, y)` and *represents* any real number `a` satisfying
`x \leq a \leq y`. We say that `R(I) = \{a \in \RR \mid x \leq a \leq y\}` is
the *represented subset* of the ``RealIntervalFieldElement`` `I`. Any
`a \in R(I)` is *represented* by `I`. Interval arithmetic makes sure that for
any `I, J \in` ``RIF`` we have `R(I) + R(J) \subseteq R(I+J)`. In words: "if `I`
represents `a` and `J` represents `b`, then `I+J` represents `a+b`".
Consider the following example::

    sage: I = RIF(3.1415, 3.1416)
    sage: J = RIF(2.7182, 2.7183)
    sage: (I+J).str(style='brackets')
    '[5.8597000000000001 .. 5.8599000000000006]'

Because `\pi \in [3.1415, 3.1416]` and `e \in [2.7182, 2.7183]`, the computation
above proves that `\pi + e \in [5.85970, 5.85991]`.
We use the same notion of a "represented subset" for idèles.

Let `K = \QQ(\alpha)` be the number field generated by `\alpha` over `\QQ`.
Let `O` be the ring of integers of `K`.
Define a *finite prime* of `K` to be a prime ideal of `O`. 
Define an *infinite prime* of `K` to be an embedding `\phi: K \to \CC` such that
`\phi(\alpha) \geq 0`.
By a *prime* of `K` we shall mean either a finite or an infinite prime of `K`.
The set of primes of `K` corresponds bijectively to the set of equivalence
classes of absolute values on `K`.

For `p` a prime of `K`, write `K_p` for the completion of `K` at `p` and call it
the *field of p-adic numbers*.
For `p` a finite prime of `K`, we denote the (normalized) valuation on `K_p` by
`ord_p: K_p \to \ZZ \cup \{\infty\}`, setting `ord_p(0) = \infty`. We denote
the corresponding valuation ring by `O_p` and call it the *ring of p-adic
integers*. For `p` an infinite prime of `K` we set `O_p = K_p`.

The *idele group* `J_K` of `K` is is the restricted product
`\prod_p'(K_p^*; O_p^*)` of the unit groups `K_p^*` with respect to the unit
groups `O_p^*`, where `p` ranges over all primes of `K`.
Concretely, that means

.. MATH::

    J_K = \left\{ (x_p)_p \in \prod_p K_p^* : x_p \in O_p^*
                  \text{ for all but finitely many } p \right\}

This is a multiplicative topological group with component-wise multiplication.
We define the *finite idele group* `J_K^0` of `K` as `\prod_p'(K_p^*; O_p^*)` as
well, but with `p` ranging only over the finite primes of `K`.

A basis of the topology on `J_K` is given by the sets

.. MATH::

    \prod_{p \in S} V_p \times \prod_{p \not\in S} O_p^*

where `S` is a finite set of primes of `K` and each `V_p` is an open subset of
`K_p`. For `p` a finite prime and `n \in \NN`, we define the open subgroup

.. MATH::

    U_p(n) = \begin{cases}
                O_p^*           & \text{if } n = 0 \\
                1 + p^n O_p     & \text{if } n > 0
             \end{cases}

of `K_p`. A system of open neighborhoods of `1 \in K_p` is given by
`\{U_p(n); n \in \NN\}`.

Let `(r,s)` be the signature of `K`. The information returned by ``K.places()``
enables us to view `J_K` as

.. MATH::

    J_K = \prod_{i=1}^r \RR \times \prod_{j=1}^s \CC \times J_K^0

Namely, the `i`-th `\RR` corresponds to `K_p` for the infinite prime
``p = K.places()[i]`` and the `j`-th `\CC` corresponds to `K_q` for
``q = K.places()[r+j]``.

In this module we define the class ``Ideles`` which represents the group `J_K`.
Storing a single idele requires an infinite amount of data in general. Hence we
will have to work with approximations to ideles. Such approximations to ideles
are implemented as the class ``Idele``; the elements of ``Ideles``.
An ``Idele`` consists out of the following data:

    - `x` -- a list of length `r+s` whose first `r` entries are elements
      of ``RIF`` and whose last `s` entries are elements of ``CIF``;
    - `f` -- a dictionary with finite primes of `K` as keys and pairs
      `(c, n) \in K^* \times \NN` as values;
    - `e` -- an element of `K^*` or ``None``; must be ``None`` if
      ``finite`` is not empty.

The standard case is that `e` is ``None`` and the ``Idele`` is determined by
`x` and `f`. In the exceptional case that `e \in K^*`, the ``Idele`` is
determined by `x` and `e` (since `f` is empty).

For `a = (x, f, e)` such an ``Idele``, write `P(a)` for the set of keys (which
are finite primes) stored in `f`. For `p \in P(a)` write `f[p]` (the *value* at
the prime `p`) as `(c_p, n_p)`. Write `x_i` for the `i`-th entry of `x`.
Then we define the *represented subset* of `a` to be the subset of `J_K`
defined by

.. MATH::

    R(a) = \prod_{i=1}^r R(x_i) \times \prod_{j=1}^s R(x_{r+j}) \times \prod_{p \in P(a)} c_p \cdot U_p(n_p) \times \prod_{p \not\in P(a)} O_p^*

in the standard case that `e` is ``None``.
If `e \in K^*` (and so `f` is empty) we say that `a` *has exact finite part* and
we define the represented subset as

.. MATH::

    R(a) = \prod_{i=1}^r R(x_i) \times \prod_{j=1}^s R(x_{r+j})
        \times \prod_p \{e\}.

We call the value `e \in K^*` the *exact finite value* of `a` in this case.

Let us look at an example with `K = \QQ`. Suppose we want to compute with an
idèle `y` specified by `y_\infty = \pi \in \RR`, `y_2 = 3/5 \in \QQ_2`, `y_5 =
-1 \in \QQ_5` and `y_p = 1 \in \QQ_p` at all other finite primes `p`.
Below we create an ``Idele`` `a` representing `y`, meaning `y \in R(a)`. ::

    sage: J = Ideles(QQ); J
    Idele Group of Rational Field
    sage: a = J([RIF(3.1415, 3.1416)], {2: (3/5, 15), 5: (-1, 15)}); a
    Idele with values:
      infinity_0:   3.1416?
      2:            3/5 * U(15)
      5:            -1 * U(15)
      other primes: 1 * U(0)

For any finite prime `p` we have `1 \cdot U_p(0) = O_p^*`. Hence the statement
``other primes: 1 * U(0)`` is consistent with our definition of `R(a)`.
Note that the ``Idele`` `a` represents the idèle `y`, but not solely `y`.
For exapmle, there are idèles with value `-1-5^{15} \in \Q_5` at `5` which are
also represented by `a`.
We can ask `a` some questions above itself::

    sage: a.stored_primes()
    [2, 5]
    sage: a.has_exact_finite_part()
    False
    sage: a.value_at(2)
    (3/5, 15)
    sage: a.value_at(97)
    (1, 0)

We call `3/5` the *center* of `a` at `2` and we call `15` the *precision* of `a`
at `2`.

We can perform ``Idele``-arithmetic::

    sage: b = J([-2], {2: (5, 12), 3: (1/3, 15), 5: (-2, 20)}); b
    Idele with values:
      infinity_0:   -2
      2:            5 * U(12)
      3:            1/3 * U(15)
      5:            -2 * U(20)
      other primes: 1 * U(0)
    sage: a * b
    ---------------------------------------------------------------------------
    TypeError
    TODO voorbeeld afmaken

.. TODO::

    Check all idele-code for edge cases:
        - finite empty
        - exact vs non-exact

    Also check idele-code in other files (i.e. Adeles._from_idele())
"""
import sys # TODO erase these two lines
sys.path.append('/home/mathe/adeles/src')

from sage.structure.element import MultiplicativeGroupElement
from sage.structure.unique_representation import UniqueRepresentation
from sage.groups.group import Group
from sage.categories.groups import Groups
from sage.arith.misc import factor
from sage.rings.integer_ring import ZZ
from sage.rings.rational_field import QQ
from sage.rings.real_mpfi import RIF
from sage.rings.complex_interval_field import ComplexIntervalField
from sage.rings.infinity import Infinity
from sage.sets.primes import Primes

from completion import completions, infinite_completions
from ray_class_group import Modulus, ray_class_group

CIF = ComplexIntervalField()
oo = Infinity


class Idele(MultiplicativeGroupElement):
    r"""
    An idele: an element of an :class:`Ideles` of a number field

    .. automethod:: __init__
    """

    def __init__(self, parent, infinite=None, finite=None, check=True):
        r"""
        Construct an idèle

        We denote the base number field by `K` and its maximal order by `O`.

        INPUT:

        - ``parent`` -- instance of :class:`Ideles`; parent idèle group
        - ``infinite`` -- ``None`` or a list or ``RIF`` or ``CIF`` elements with
          as many entries as `K` has infinite places. The ``i``-th entry
          specifies the value of this idèle at the infinite place corresponding
          to ``K.places()[i]``. The entry should be non-zero and lie in ``RIF``
          or ``CIF``, depending on the place being real or complex.
          ``None`` means we do not know anything about the values of this idele
          at infinite primes.
        - ``finite`` -- a dictionary or an element of `K^*` (default: empty
          dictionary);

          If ``finite`` is a dictionary, it should contain (``key``, ``value``)
          pairs such that:

              - ``key`` is a finite prime `p` of ``K``; if ``K`` is `\QQ`, this
                is a prime number, else it's a prime ideal of ``O``.
              - ``value`` should be a pair (``x``, ``i``) with ``x`` an element
                of `K^*` and ``i`` a non-negative integer.

          Such an entry means: at prime `p` of `K`, this idele is equal to (the
          image of) ``x`` (in `K_p`), up to multiplication with elements of the
          ``n``-th standard subgroup of `K_p^*`.

          If ``finite`` lies in `K^*`, then this specifies the exact
          finite value of this idele. Then the value of this idele is exactly
          equal to ``finite`` at each finite prime of `K`.

        - ``check`` -- boolean (default: ``True``): whether or not to validate
          the input data

        EXAMPLES:

        We begin with the easiest case: `K = \QQ`::

            sage: J = Ideles(QQ)
            sage: Idele(J, [3.14], {2: (5/3, 2), 5: (1, 9)})
            Idele with values:
              infinity_0:   3.1400000000000002?
              2:            5/3 * U(2)
              5:            1 * U(9)
              other primes: 1 * U(0)
            sage: Idele(J, [RIF(-1.122, -1.119)], 1/3)
            Idele with values:
              infinity_0:   -1.12?
              other primes: 1/3
            sage: Idele(J, None, None)
            Idele with values:
              infinity_0:   RR^*
              other primes: 1 * U(0)

        Now let's take a non-trivial number field::

            sage: K.<a> = NumberField(x^4-17)
            sage: Jk = Ideles(K)
            sage: p3, p7 = K.prime_above(3), K.prime_above(7)
            sage: Idele(Jk, [3.14, -1, 1+I], {p3: (a^3, 7), p7: (-a-1, 4)})
            Idele with values:
              infinity_0:   3.1400000000000002?
              infinity_1:   -1
              infinity_2:   1 + 1*I
              (3, 1/2*a^2 - a - 1/2):       a^3 * U(7)
              (7, 1/2*a^2 + a - 5/2):       (-a - 1) * U(4)
              other primes: 1 * U(0)
            sage: Idele(Jk, None, a^3-a^2+2*a-5)
            Idele with values:
              infinity_0:   RR^*
              infinity_1:   RR^*
              infinity_2:   CC^*
              other primes: a^3 - a^2 + 2*a - 5 

        TESTS::

            sage: Idele(J, [1], 0)
            Traceback (most recent call last):
            ...
            ValueError: exact finite value must be non-zero
            sage: Idele(J, [1], "blah")
            Traceback (most recent call last):
            ...
            TypeError: finite must be a dictionary or a non-zero number field element

        .. TODO::

            Implement parameter ``check=True``
        """
        MultiplicativeGroupElement.__init__(self, parent)
        K = parent.number_field()

        self._infinite = infinite
        if check:
            self._validate_infinite()

        self._finite = finite
        if check:
            self._validate_finite()

    def _validate_infinite(self):
        """
        Raise an exception if ``self._infinite`` is not valid

        ``self._infinite`` is valid if it's a list of length ``len(K.places())``
        with the `i`-th entry a non-zero element of ``RIF`` if ``K.places()[i]``
        is real and a non-zero element of ``CIF`` otherwise.
        Note that only the intervals `[0, 0]` in ``RIF`` and `[0, 0] + [0,0]*I`
        in ``RIC`` are zero. For example, `[-1, 5]` is non-zero although it does
        represent zero.

        If the `i`-th entry's parent is not equal to ``RIF``/``CIF``, but does
        lie in it, than we cast the element to an actual element of such an
        interval field.

        EXAMPLES:

        We look at a number field with one real and one complex prime::

            sage: K.<a> = NumberField(x^3 + x + 1)
            sage: Jk = Ideles(K)
            sage: u = Jk(1)
            sage: u._infinite = [1.2, I]
            sage: u._validate_infinite()

        Below the ``Integer 3`` will be cast into ``RIF`` and ``I`` will be cast
        into ``CIF``::

            sage: u._infinite = [ZZ(3), I]
            sage: u._validate_infinite()
            sage: u._infinite[0].parent()
            Real Interval Field with 53 bits of precision
            sage: u._infinite[1].parent()
            Complex Interval Field with 53 bits of precision

        If ``_infinite`` is ``None``, we make a list of ``RR``s and ``CC``s of
        if::

            sage: u._infinite = None
            sage: u._validate_infinite()
            sage: u
            TODO

        The exceptions that we may throw:

            sage: u._infinite = [3.14, I, I]
            sage: u._validate_infinite()
            Traceback (most recent call last):
            ...
            ValueError: infinite must have length 2
            sage: u._infinite = {CIF: I+1}
            sage: u._validate_infinite()
            Traceback (most recent call last):
            ...
            TypeError: infinite must be a list
            sage: u._infinite = [I, I]
            sage: u._validate_infinite()
            Traceback (most recent call last):
            ...
            TypeError: 0th infinite value (I) must lie in Real Interval Field with 53 bits of precision
            sage: u._infinite = [1, CIF(0)]
            sage: u._validate_infinite()
            Traceback (most recent call last):
            ...
            ValueError: 1th infinite value (0) must be non-zero
        """
        K = self.parent().number_field()

        if self._infinite is None:
            r1, r2 = K.signature()
            RR = RIF(-oo, oo)
            CC = CIF(RR, RR)
            self._infinite = [RR for i in range(r1)] + [CC for i in range(r2)]
            return

        K_oo = infinite_completions(K, fields_only=True)
        t = len(K_oo)

        if not isinstance(self._infinite, list):
            raise TypeError("infinite must be a list")

        if len(self._infinite) != t:
            raise ValueError("infinite must have length {}".format(t))

        for i in range(t):
            val = self._infinite[i]
            if val not in K_oo[i]:
                raise TypeError("{}th infinite value ({}) must lie in {}".format(i, val, K_oo[i]))
            if val == 0:
                raise ValueError("{}th infinite value ({}) must be non-zero".format(i, val))
            self._infinite[i] = K_oo[i](val)

    def _validate_finite(self):
        r"""
        Raise an exception if ``self._finite`` is not valid
    
        ``self._finite`` is valid if it is a dictionary with keys finite primes of
        `K` (our base number field) and values pairs in `K^* \times \NN`.
        A finite prime of `K` is a prime number if `K` is `\QQ` and a prime
        ideal of the ring of integers of `K` otherwise.

        This method also casts the entries of each value pair ``(x, n)`` into
        `K` and ``ZZ``.

        EXAMPLES:

        A few examples of the small adjustments we can do::

            sage: K.<a> = NumberField(x^4+x+1)
            sage: J = Ideles(K)
            sage: u = J(1)
            sage: u._finite = {a+3: (int(3), int(1))}
            sage: u._validate_finite()
            sage: u._finite # a+3 is turned into an ideal:
            {Fractional ideal (a + 3): (3, 1)}
            sage: u.finite(a+3)[0].parent() # 3 into a number field element
            Number Field in a with defining polynomial x^4 + x + 1
            sage: u.finite(a+3)[1].parent() # 1 into a Sage Integer
            Integer Ring

        ::

            sage: u._finite = None
            sage: u._validate_finite()
            sage: u._finite
            {}

        And some exceptions we may throw::

            sage: u._finite = 0
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            TypeError: exact finite value must be non-zero
            sage: u._finite = "blah"
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            TypeError: finite must be a dictionary or a non-zero number field element

        Keys must be primes of K. Although 5 is a prime number, it is not a
        prime of `K` as 5 splits into two primes in `K`::

            sage: u._finite = {5: (1, 1)}
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            TypeError: keys of finite must be prime ideals of the number field

        Values are checked for correctness as well::

            sage: u._finite = {K.prime_above(2): (1, -1)}
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            TypeError: values at finite primes must be pairs in K x NN
            sage: u._finite = {K.prime_above(2): ([], 3)}
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            TypeError: values at finite primes must be pairs in K x NN
        """
        K = self.parent().number_field()

        if self._finite is None:
            self._finite = {}
        elif self._finite in K:
            if self._finite == 0:
                raise ValueError("exact finite value must be non-zero")
            self._exact = K(self._finite)
        elif isinstance(self._finite, dict):
            # We will replace self._finite will our own dictionary ``finite`` in
            # which we ensure all keys and values have the correct parents.
            finite = {}
            for P, val in self._finite.items():
                if K is QQ:
                    if P not in Primes():
                        raise TypeError("keys of finite must be prime numbers")
                    P = ZZ(P)
                else:
                    if P not in K.ideal_monoid() or not K.ideal(P).is_prime():
                        raise TypeError("keys of finite must be prime ideals of the number field")
                    P = K.ideal(P)
                
                try:
                    center, prec = val
                except TypeError:
                    raise TypeError("values at finite primes must be pairs in K^* x NN")
                if center not in K or center == 0 or prec not in ZZ or prec < 0:
                    raise TypeError("values at finite primes must be pairs in K^* x NN")

                finite[P] = (K(center), ZZ(prec))

            self._finite = finite
        else:
            raise TypeError("finite must be a dictionary or a non-zero number field element")

    def _repr_(self):
        """
        Return a representation of this idele.

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J(1/2, None, {97: (7/9, 20)}); u
            Idele with values:
              infinity_0:   RR^*
              97:           7/9 * U(20)
              other primes: 1 * U(0)
            sage: v = J([-7.123456], 5/8); v
            Idele with values:
              infinity_0:   -7.1234560000000001?
              other primes: 5/8
        """
        K = self.parent().number_field()
        rep = "Idele with values:"

        RR = RIF(-oo, oo)
        CC = CIF(RR, RR)
        for i in range(len(self.infinite_part())):
            x_i = self[oo, i]
            if x_i.endpoints() == RR.endpoints():
                rep += "\n  infinity_{}:\tRR^*".format(i)
            elif x_i.endpoints() == CC.endpoints():
                rep += "\n  infinity_{}:\tCC^*".format(i)
            else:
                rep += "\n  infinity_{}:\t{}".format(i, x_i)

        for P in self.stored_primes():
            center, prec = self[P]
            p_name = str(P) if K is QQ else str(P.gens_two())
            tab = "\t\t" if len(p_name) < 5 else "\t"
            if len([c for c in center.list() if not c.is_zero()]) > 1:
                center = "(" + str(center) + ")"
            rep += "\n  {}:{}{} * U({})".format(p_name, tab, center, prec)

        if self.has_exact_finite_part():
            rep += "\n  other primes:\t{}".format(self.exact_finite_value())
        else:
            rep += "\n  other primes:\t1 * U(0)"

        return rep

    def stored_primes(self):
        r"""
        Return the set of stored primes of this idele as an ordered list.

        A stored prime is a finite prime of the base number field `K` for which
        this idele has stored a value in its ``_finite`` attribute.
        
        The order is determined by the implemented order on number field ideals,
        or by the natural order on `\NN` if `K = \QQ` (in which case the primes
        are prime numbers).

        EXAMPLES::

            sage: K.<a> = NumberField(x^2+17)
            sage: J = Ideles(K)
            sage: p2, p5 = K.prime_above(2), K.prime_above(5)
            sage: p7, q7 = K.primes_above(7)
            sage: u = J([I], {q7: (a, 1), p2: (8, 0), p7: (1,0), p5: (a, 3)})
            sage: u.stored_primes()
            [Fractional ideal (2, a + 1),
             Fractional ideal (5),
             Fractional ideal (7, a + 2),
             Fractional ideal (7, a + 5)]
        """
        return sorted(list(self.finite_part().keys()))

    def has_exact_finite_part(self):
        """
        Return whether or not this idele has exact finite part

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J([-1], 7)
            sage: u.has_exact_finite_part()
            True
            sage: v = J([-1], {2: (1, 1)})
            sage: v.has_exact_finite_part()
            False
        """
        K = self.parent().number_field()
        return self._finite in K

    def infinite_part(self, index=None):
        """
        Return the infinite part of this idele as a list
        """
        return self._infinite

    def finite_part(self, prime=None):
        """
        Return the finite part of ``self`` as a dictionary
        """
        return self._finite

    def __getitem__(self, prime):
        """
        Get the value of this idèle at the prime ``prime``

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J([3.1], {2: (1,2)})
            sage: u[oo]
            3.1000000000000001?
            sage: u[2]
            (1, 2)
            sage: u[3]
            (1, 0)
            sage: u[4]
            Traceback (most recent call last):
            ...
            TypeError: You can only index by a prime ideal or (Infinity, index)

        ::

            sage: K.<a> = NumberField(x^2+7)
            sage: Jk = Ideles(K)
            sage: v = Jk([I], {K.prime_above(5): (a, 3)})
            sage: v[oo]
            1*I
            sage: v[oo, 0]
            1*I
            sage: v[K.prime_above(2)]
            (1, 0)
            sage: v[K.prime_above(5)]
            (a, 3)
            sage: v[7]
            Traceback (most recent call last):
            ...
            KeyError: You can only index by a prime ideal or (Infinity, index)
        """
        K = self.parent().number_field()
        if ((K is QQ and prime in Primes()) or
                (prime in K.ideal_monoid() and K.ideal(prime).is_prime())):
            if self.has_exact_finite_part():
                return self.finite_part()
            try:
                return self.finite_part()[prime]
            except KeyError:
                return (K(1), ZZ(0))
        if prime is Infinity and len(self.infinite_part()) == 1:
            return self.infinite_part()[0]
        try:
            inf, index = prime
            if inf is Infinity:
                return self.infinite_part()[index]
        except TypeError:
            pass
        raise KeyError("You can only index by a prime ideal or (Infinity, index)")


    def _equals(self, other):
        """
        Return whether or not ``self`` equals ``other``

        We define equality of ideles very loosely: if two ideles *could* be
        equal, that is if the open subsets they represent have non-empty
        intersection, than we declare them equal.

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J(None, None, {2: (3, 7), 3: (1/2, 6)})
            sage: v = J(4, [-1.23], {3: (5, 10)})
            sage: w = J(None, None, {2: (3, 7), 3: (1/2, 6), 5: (1, 0)})
            sage: u._equals(u)
            True
            sage: (u/u)._equals(J(1))
            True
            sage: u._equals(v)
            False
            sage: u._equals(w)
            True
            sage: v._equals(w)
            False

        If an idele ``x`` represents a strict subset of another idele ``v``,
        they are equal::

            sage: x = J(4, [-1.23], {3: (5, 11)})
            sage: v._equals(x)
            True

        Also in this case the result is not equal, due to the non-exactness of
        ``u``::
        """
        K = self.parent().number_field()

        if self.has_exact_finite_part() and other.has_exact_finite_part():
            if self.exact_finite_value() != other.exact_finite_value():
                return False
        elif self.has_exact_finite_part() or other.has_exact_finite_part():
            ex, nex = (self, other) if self.has_exact_finite_part() else (other, self)
            if not nex._contains(ex.exact_finite_value()):
                return False

        t = len(self.infinite())
        for i in range(t):
            try:
                intersection = self.infinite(i).intersection(other.infinite(i))
                if intersection.is_zero():
                    return False
            except ValueError:
                # This indicates the intersection is empty
                return False

        for q, v in self.finite().items():
            if q in other.finite():
                w = other.finite(q)
                small, big = (self, other) if v[1] >= w[1] else (other, self)
                if not big._contains_at(small.finite(q)[0], q):
                    # the small open subset does not lie in the big open subset
                    # so they are disjoint
                    return False
            else: # other[q] not stored
                if other.has_exact_finite_part():
                    if not self._contains_at(other.exact_finite_value(), q):
                        return False
                else:
                    x = v[0]
                    # other[q] is Z_q*
                    # So x must lie in Z_q*, i.e. have valuation zero
                    if K is not QQ:
                        x = K.ideal(x)
                    if  x.valuation(q) != 0:
                        return False
        for q, v in other.finite().items():
            if q not in self.finite():
                if self.has_exact_finite_part():
                    # self[q] has exact finite part, while other[q] is an approximation.
                    return False
                else:
                    x = v[0]
                    # self[q] is Z_q*
                    # So x must lie in Z_q*, i.e. have valuation zero
                    if K is not QQ:
                        x = K.ideal(x)
                    if x.valuation(q) != 0:
                        return False

        # Passed all checks. We are equal!
        return True

    def _richcmp_(self, other, op):
        """
        Return the result of operator ``op`` applied to ``self`` and ``other``

        Only equality and inequality are implented.

        EXAMPLES::

            sage: K.<a> = NumberField(x^5-x+2)
            sage: J = Ideles(K)
            sage: u = J(a^4+1, None, {K.prime_above(11): (a^3-a, 20)})
            sage: v = J(None, None, {K.prime_above(97): (a, 20)})
            sage: v == u
            False
            sage: v != u
            True
            sage: u == u
            True
            sage: u != u
            False
        """
        from sage.structure.richcmp import op_EQ, op_NE
        if op == op_EQ:
            return self._equals(other)
        if op == op_NE:
            return not self._equals(other)
        raise NotImplementedError()

    
    def _mul_(self, other):
        """
        Multiply ``self`` and ``other`` together

        .. NOTE::

            Precision may be lost. See the examples below.

        EXAMPLES:

        First a few multiplications of rational ideles::

            sage: J = Ideles(QQ)
            sage: u = J(None, None, {2: (1/2, 7), 3: (2/5, 8)})
            sage: v = J(None, [1.2345], None)
            sage: w = J(1/7, [-1.0], {3: (-1, 7)})
            sage: u*v
            Idele with values:
              infinity_0:  RR^*
              2:            1/2 * U(0)
              3:            2/5 * U(0)
            sage: u*w
            Idele with values:
              infinity_0:  RR^*
              2:            1/14 * U(7)
              3:            -2/5 * U(7)
              7:            1/7 * U(0)
            sage: w*u
            Idele with values:
              infinity_0:       RR^*
              2:                1/14 * U(7)
              3:                -2/5 * U(7)
              7:                1/7 * U(0)
            sage: v*w
            Idele with values:
              infinity_0:   -1.2345000000000000?
              3:            -1 * U(0)
              7:            1/7 * U(0)

        And now a few over a non-trivial number field::

            sage: K.<i> = NumberField(x^2+1)
            sage: J = Ideles(K)
            sage: p2, p3 = K.prime_above(2), K.prime_above(3)
            sage: u = J(i+1)
            sage: v = J(None, [I+1], {p3: (i/2, 7)})
            sage: w = J(i-1, None, {p2: (2, 5), p3: (3*i, 20)})
            sage: u*v
            Idele with values:
              infinity_0:       2*I
              (2, i + 1):       (i + 1) * U(0)
              (3, 0):   (1/2*i - 1/2) * U(7)
            sage: u*w
            Idele with values:
              infinity_0:  CC^*
              (2, i + 1):   (2*i + 2) * U(5)
              (3, 0):       (3*i - 3) * U(20)
              elsewhere:    -2
            sage: v*w
            Idele with values:
              infinity_0:  CC^*
              (2, i + 1):   2 * U(0)
              (3, 0):       -3/2 * U(7)
        """
        K = self.parent().number_field()

        exact = None
        if self.has_exact_finite_part() and other.has_exact_finite_part():
            exact = self.exact_finite_value() * other.exact_finite_value()

        infinite = self.infinite().copy()
        for i in range(len(infinite)):
            infinite[i] *= other.infinite(i)

        finite = self.finite().copy()
        for q, val in finite.items():
            if q in other.finite():
                x, i = val
                y, j = other.finite(q)
                finite[q] = (x*y, min(i, j))
            else:
                if other.has_exact_finite_part():
                    finite[q] = (val[0] * other.exact_finite_value(), val[1])
                else: # other is unknown (i.e. Z_q^*) at q
                    # U_q^i is a subgroup of Z_q^*, so x*U_q^i * Z_q^* = x*Z_q^*
                    finite[q] = (val[0], ZZ(0)) 
        for q, val in other.finite().items():
            if q not in finite:
                if self.has_exact_finite_part():
                    finite[q] = (val[0] * self.exact_finite_value(), val[1])
                else: # self is unknown (i.e. Z_q^*) at q
                    # U_q^i is a subgroup of Z_q^*, so x*U_q^i * Z_q^* = x*Z_q^*
                    finite[q] = (val[0], ZZ(0))
        if ((self.has_exact_finite_part() and not other.has_exact_finite_part())
                or (not self.has_exact_finite_part() and other.has_exact_finite_part())):
            # One has an exact value and one is Z_q^* almost everywhere.
            value = self.exact_finite_value() if self.has_exact_finite_part() else other.exact_finite_value()
            # Where value has valuation 0, we have value * Z_q^* = Z_q^*, so we
            # don't have to store this.
            # But at the finitely many places where value has non-zero
            # valuation, we must store "value * Z_q^*".
            if K is QQ:
                I = value
            else:
                I = K.ideal(value)
            for q, e in factor(I):
                if q not in finite:
                    finite[q] = (value, ZZ(0))

        return self.__class__(self.parent(), exact, infinite, finite)

    def inverse(self):
        """
        Return the inverse of ``self`` in its idele group (i.e. "1/``self``")

        EXAMPLES::

            sage: K.<a> = NumberField(x^2+x+1)
            sage: p2, p3 = K.prime_above(2), K.prime_above(3)
            sage: J = Ideles(K)
            sage: u = J(None, [I], {p2: (a, 10), p3: (1/2, 7)})
            sage: u.inverse()
            Idele with values:
              infinity_0:   -1*I
              (2, 0):       (-a - 1) * U(10)
              (3, a + 2):   2 * U(7)
            sage: v = J(5, [1/2-I], {p3: (a+1, 97)})
            sage: v.inverse()
            Idele with values:
              infinity_0:   0.4000000000000000? + 0.80000000000000005?*I
              (3, a + 2):   -a * U(97)
              elsewhere:    1/5
        """
        exact = None
        if self.has_exact_finite_part():
            exact = ZZ(1) / self.exact_finite_value()

        infinite = self.infinite().copy()
        for i in range(len(infinite)):
            infinite[i] = ZZ(1) / infinite[i]

        finite = self.finite().copy()
        for q, val in finite.items():
            finite[q] = (ZZ(1) / val[0], val[1])

        return self.__class__(self.parent(), exact, infinite, finite)

    def _div_(self, other):
        """
        Divide ``self`` by ``other``

        EXAMPLES::

            sage: K.<a> = NumberField(x^2+8)
            sage: p2, q3 = K.prime_above(2), K.primes_above(3)[1]
            sage: J = Ideles(K)
            sage: u = J(None, [I+1], {p2: (a-1, 7), q3: (a/2, 9)})
            sage: v = J(a, [3], {q3: (2, 10)})
            sage: u/v
            Idele with values:
              infinity_0:   0.3333333333333334? + 0.3333333333333334?*I
              (2, 1/2*a):   (1/8*a + 1) * U(7)
              (3, 1/2*a + 2):       1/4*a * U(9)
            sage: v/u
            Idele with values:
              infinity_0:   1.5000000000000000? - 1.5000000000000000?*I
              (2, 1/2*a):   (-1/9*a + 8/9) * U(7)
              (3, 1/2*a + 2):       -1/2*a * U(9)
            sage: u/u
            Idele with values:
              infinity_0:   1
              (2, 1/2*a):   1 * U(7)
              (3, 1/2*a + 2):       1 * U(9)
        """
        return self * other.inverse()

    def integral_split(self):
        """
        Return a tuple ``(u, d)`` with ``u` an "integral" idele and ``d`` an
        integer such that ``self = u/d``

        The "integrality" of ``u`` is strong, in the following sense: at every
        finite prime `q` at which we stored a value `(x, i)` (representing
        `x*U_q^i`), the `K`-element ``x`` is integral in `K`; and if ``u`` is
        exact, its exact value is also integral in `K`.
        This is stronger than ``u`` being locally everywhere integral.

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J(None, None, {2: (1/4, 1), 3: (3/5, 2)})
            sage: u.integral_split()
            (Idele with values:
               infinity_0: RR^*
               2:           5 * U(1)
               3:           12 * U(2)
               5:           20 * U(0),
             20)
            sage: v = J(3/14, [1], {2: (3/4, 5), 3: (1, 3)})
            sage: v.integral_split()
            (Idele with values:
               infinity_0:  28
               2:           21 * U(5)
               3:           28 * U(3)
               elsewhere:   6,
             28)
            sage: K.<a> = NumberField(x^2+10)
            sage: p3, p5 = K.prime_above(3), K.prime_above(5)
            sage: Jk = Ideles(K)
            sage: u = Jk(None, [I], {p3: (1/a, 3), p5: (7/6, 8)})
            sage: u.integral_split()
            (Idele with values:
               infinity_0:  30*I
               (2, a):      30 * U(0)
               (3, 0):      -3*a * U(3)
               (5, a):      35 * U(8),
             30)
        """
        from sage.arith.functions import lcm
        K = self.parent().number_field()

        denominators = []
        factors = factor(ZZ(1))
        for q, val in self.finite().items():
            d_q = val[0].denominator()
            denominators.append(d_q)
            if K is not QQ:
                d_q = K.ideal(d_q)
            factors *= factor(d_q)
        if self.exact_finite_value() is not None:
            d_exact = self.exact_finite_value().denominator()
            denominators.append(d_exact)
            if K is not QQ:
                d_exact = K.ideal(d_exact)
            factors *= factor(d_exact)
        d = lcm(denominators)

        # Now returning (d*self, d) would be correct. The multiplication will
        # usually need to factor d, which may be expensive. Less expensive is
        # to factor all the individual d_q's (as we did above) and build up our
        # ``u`` directly. This is what we will do below.

        finite = {}
        for q, val in self.finite().items():
            finite[q] = (d*val[0], val[1])
        exact = None
        if self.has_exact_finite_part():
            exact = self.exact_finite_value() * d
        else:
            for q, e in factors:
                if q not in finite:
                    finite[q] = (d, ZZ(0))
        infinite = self.infinite().copy()
        for i in range(len(infinite)):
            infinite[i] = d*infinite[i]
        u = self.__class__(self.parent(), exact, infinite, finite)

        return (u, d)

    def to_modulo_element(self):
        r"""
        Convert this idele to its image in O/I, with O the maximal order of K
        and I the (biggest) ideal where ``self`` is defined

        This implements the canonical homomorphism `\hat{O} \to O/I`, where
        we view `\hat{O}` as the subring of the idele group of ideles which are
        everywhere integral.

        Throws an exception if ``self`` does not lie in this subring.

        INPUT:

        - ``I`` -- an ideal of the maximal order ``O`` of our number field ``K``

        EXAMPLES:
            
        sage: J = Ideles(QQ)
        sage: u = J(None, None, {2: (1/3, 3), 5: (7, 1)})
        sage: u_bar = u.to_modulo_element()
        sage: u_bar, u_bar.parent()
        (27, Ring of integers modulo 40)
        """
        from adele import Adeles
        A = Adeles(self.parent().number_field())
        return A(self).to_modulo_element()

    def to_ray_class(self, modulus):
        r"""
        Return the image of ``self`` in the ray class group modulo ``modulus``

        Let `K` denote our number field and let `O` denote its maximal order.
        Let `I(modulus)` be the group of fractional `O`-ideals coprime to
        ``modulus`` and let `R(modulus)` denote the ray modulo ``modulus``.
        Hence the ray class group of `K` modulo ``modulus`` is
        `I(modulus)/R(modulus)`.
        Write `J_K` for the group of ideles of `K` (to which ``self`` belongs).

        This method implementst the homomorphism

        .. MATH::

            \phi: J_K \to I(modulus)/R(modulus)

        that sends a prime element at a finite prime `q` (not dividing `m`) to
        `q \mod R(modulus)`.

        INPUT:

        - ``modulus`` -- a :class:`Modulus` of `K`

        OUTPUT:

        The image of ``self`` under `\phi`.

        EXAMPLES::

            sage: Q = NumberField(x-1, "one")
            sage: J = Ideles(Q)
            sage: u = J(None, [-9], {2: (10, 1), 3: (3, 2), 7: (1/2, 4)})
            sage: m = Modulus(Q.ideal(18), [0])
            sage: u.to_ray_class(m).ideal()
            Fractional ideal (7)

        ::

            sage: K.<a> = NumberField(x^3-x-1)
            sage: Jk = Ideles(K)
            sage: p7, q7 = K.primes_above(7)
            sage: u = Jk(None, [2, I], {p7: (1/2, 1), q7: (7*a, 2)})
            sage: m = Modulus(K.ideal(7), [0])
            sage: u.to_ray_class(m).ideal()
            Fractional ideal (-2*a^2 - 3*a + 3)

        TESTS::

            sage: K = NumberField(x^2 + 5*x - 3, 'a')
            sage: J = Ideles(K)
            sage: G = ray_class_group(K, Modulus(K.ideal(14), [0])); G
            Ray class group of order 18 with structure C6 x C3 of Number Field in a with defining polynomial x^2 + 5*x - 3 of modulus (Fractional ideal (14)) * infinity_0
            sage: c0, c1 = G.gens()
            sage: for e in range(6):
            ....:     for f in range(3):
            ....:         r = c0^e * c1^f
            ....:         assert G(J(r)) == r, "bug!"  # long

        .. TODO::

            Implement the case that ``self`` has exact.

        ALGORITHM:

        We construct an idele `v` satisfying:
            - `v \equiv self \mod K^*`
            - `v \equiv 1 \mod^* modulus`

        We do this by starting of with `v = self` and then improve `v` in three
        steps:

            1. Make `v` integral at the primes dividing ``modulus``.
            2. Make `v \equiv 1 \mod^*` ``modulus.finite_part()``
            3. Make `v \equiv 1 \mod^*` ``modulus`` (fix the infinite part)

        In every step we only change `v` by multiplying it with principal ideles
        (i.e. elements of K^*) as to never violate the first desired condition
        on `v`.
        For Step 2 we use the number field version of the Chinese Remainder
        Theorem (cf. :func:`solve_CRT`). For Step 3 we use
        :meth:`get_one_mod_star_finite_with_fixed_signs`.

        Once we have such a `v`, we return the image of the ideal
        `\prod_{p} p^{\ord_p(v)}` in ``G``, where `p` ranges over the finite
        primes of `K`.
        """
        if self.has_exact_finite_part():
            raise NotImplementedError("to_ray_class() not implemented yet for exact ideles")

        J = self.parent()
        K = J.number_field()
        G = ray_class_group(K, modulus)

        # First we check if the precision of this idele is high enough to have
        # a well-defined image in the ray class group ``G``.
        for i in modulus.infinite_part():
            if (not (self.infinite(i) <= 0 or self.infinite(i) >= 0)
                    or self.infinite(i).is_zero()):
                raise ValueError("idele has no well-defined sign at infinite prime {}".format(i))
        for q, e in modulus.finite_factors():
            if q not in self.finite() or self.finite(q)[1] < e:
                raise ValueError("idele must be known up to at least U_q^{} at q={}".format(e, q))

        v = self
        # Step 1. We make `v` integral at the primes dividing modulus.
        for q, e in modulus.finite_factors():
            x, i = self.finite(q)
            if x not in K.maximal_order():
                v *= x.denominator()

        # Step 2. We find an element y in the maximal order O_K of K such that
        # y \equiv v \mod modulus.finite_part() using the Chinese Remainder
        # Theorem.
        values = []
        moduli = []
        for q, e in modulus.finite_factors():
            x, i = v.finite(q)
            f = i + x.valuation(q)
            # v represents x*U_q^i at q, which equals x+q^f\Z_q because
            # i >= modulus.valuation(q) >= 1 and x.valuation(q) >= 0 (so we
            # do not need to worry about the case i==0 representing x*Z_q^*)
            values.append(x)
            moduli.append(q**f)
        y = K.solve_CRT(values, moduli)
        if not y.is_zero():
            # y is zero if and only if values and moduli are empty, so when
            # modulus is infinite. In that case we can just leave v as it is.
            v /= J(y)
        # Now we have v \equiv 1 \mod^* modulus.finite_part().
        

        # Step 3. We address the infinite part using the Modulus-method
        # get_one_mod_star_finite_with_fixed_signs().
        positive = []
        negative = []
        for i in modulus.infinite_part():
            if v.infinite(i) >= 0:
                positive.append(i)
            else:
                negative.append(i)
        t = modulus.get_one_mod_star_finite_with_fixed_signs(positive, negative)
        v *= t

        # TODO do not do the redundant check below to save its costs
        assert v.is_one_mod_star(modulus), r"Assertion error in Idele.to_ray_class(): v \not\equiv 1 \mod^* m"

        # Our `v` is finished. We can now build up an ideal representing the
        # image of `v` (which is equal to the image of ``self``) in ``G``.
        I = K.unit_ideal()
        for q, val in v.finite().items():
            I *= q**(val[0].valuation(q))

        return G(I)


    def is_one_mod_star(self, modulus):
        r"""
        Return whether or not ` ``self`` \equiv 1 \mod^\ast ``modulus`` ` holds

        EXAMPLES::

            sage: Q = NumberField(x-1, "one")
            sage: J = Ideles(Q)
            sage: u = J(None, None, {5: (6, 2)})
            sage: u.is_one_mod_star(Modulus(Q.ideal(3)))
            False
            sage: u.is_one_mod_star(Modulus(Q.ideal(5)))
            True
            sage: u.is_one_mod_star(Modulus(Q.ideal(25)))
            False
            sage: u.is_one_mod_star(Modulus(Q.ideal(5), [0]))
            False
            sage: u._infinite[0] = RIF(1.2345)
            sage: u.is_one_mod_star(Modulus(Q.ideal(5), [0]))
            True
            sage: u._infinite[0] = RIF(-1.2345)
            sage: u.is_one_mod_star(Modulus(Q.ideal(5), [0]))
            False
            sage: u._exact = Q.one()
            sage: u.is_one_mod_star(Modulus(Q.ideal(2*3*5*7*11)))
            True
        """
        for q, e in modulus.finite_factors():
            if not q in self.finite():
                if not self.has_exact_finite_part():
                    return False
                x = self.exact_finite_value()
            else:
                x, i = self.finite(q)
                if i < e:
                    return False
            if (x-1).valuation(q) < e:
                return False
        for i in modulus.infinite_part():
            if not (self.infinite(i) >= 0):
                return False
        return True

    def _contains_at(self, x, q):
        r"""
        Check if this idele contais the `K`-element ``x`` at the prime ``q``

        Suppose that the open subset this idele represents is `U_q^i` at ``q``.
        Then we check whether or not `x \in U_q^i` holds.

        INPUT:

        - ``x`` -- element of `K`
        - ``q`` - prime (finite or infinite) of `K`; in the infinite case, it
          should be one of the embbedings returned by ``K.places()``.

        EXAMPLES:
        
        First some examples with `\QQ`::

            sage: J = Ideles(QQ)
            sage: u = J(None, None, {2: (5, 3), 3: (1/3, 0)})
            sage: u._contains_at(5, 2)
            True
            sage: u._contains_at(2, 2)
            False
            sage: u._contains_at(5/3, 3)
            True
            sage: u._contains_at(5/9, 3)
            False
            sage: u._contains_at(13, 5)
            True
            sage: u._contains_at(130, 5)
            False
            sage: u._contains_at(3.1415, QQ.places()[0])
            True

        And some examples with a non-trivial number field::

            sage: K.<a> = NumberField(x^3+x+1)
            sage: Jk = Ideles(K)
            sage: v = Jk(a, [RIF(-0.68, -0.69), I], {K.prime_above(7): (a+1, 8)})
            sage: v._contains_at(a, K.places()[0])
            True
            sage: v._contains_at(a+1, K.places()[0])
            False
            sage: v._contains_at(a, K.places()[1])
            False
            sage: v._contains_at(a, K.prime_above(7))
            False
            sage: v._contains_at((a+1)*(7^8+1), K.prime_above(7))
            True

        And lastly some errors that may occur:

            sage: u._contains_at(1, 8)
            Traceback (most recent call last):
            ...
            TypeError: ``q`` should be a prime of `K`, but got 8
            sage: v._contains_at(a^2, None)
            Traceback (most recent call last):
            ...
            TypeError: ``q`` should be a prime of `K`, but got None
        """
        K = self.parent().number_field()
        if q in K.places():
            i = K.places().index(q)
            phi = completions(K, oo)[i][1] # phi: K --> RIF/CIF
            return phi(x) in self.infinite(i)

        if (K is QQ and q in Primes()) or (K is not QQ and q in K.ideal_monoid() and q.is_prime()):
            if q in self.finite():
                y, i = self.finite(q)
                if i == ZZ(0):
                    return (x/y).valuation(q) == ZZ(0)
                else:
                    return (x/y - 1).valuation(q) >= i
            elif self.has_exact_finite_part():
                return x == self.exact_finite_value()
            else:
                # Not stored represents Z_q^*: the elements of valuation 0.
                return x.valuation(q) == 0

        raise TypeError("``q`` should be a prime of `K`, but got {}".format(q))

    def _contains(self, x):
        """
        Check if the subset this idele represents contains the `K`-element ``x``

        INPUT:

        - ``x`` -- element of `K`, the number field to which this idele belongs

        EXAMPLES::

            sage: K.<a> = NumberField(x^7-4/7*x^3+1)
            sage: J = Ideles(K)
            sage: u = J(a^5-a)
            sage: v_oo = completions(K, oo)[0][1](a^3)
            sage: C = CIF(RIF(-oo, oo), RIF(-oo, oo))
            sage: v = J(None, [v_oo, C, C, C], {K.prime_above(5): (a^3, 4)})
            sage: u._contains(a^5-a)
            True
            sage: u._contains(1)
            False
            sage: v._contains(a^3)
            True
            sage: v._contains(a)
            False
        """
        if self.has_exact_finite_part() and x != self.exact_finite_value():
            return False
        K = self.parent().number_field()
        for phi in K.places():
            if not self._contains_at(x, phi):
                return False
        for q in self.finite():
            if not self._contains_at(x, q):
                return False
        return True

    def is_principal(self):
        """
        Return whether or not this idele is principal

        We check if there exists an "original" rational ``r`` whose image lies in
        the open subset op the idele group that this idele represents.

        ALGORITHM:

        If this idele has an exact value, that is our only candidate for ``r``.
        Else we create a generator by ... TODO

        EXAMPLES::

            sage: K.<a> = NumberField(x^2+3)
            sage: J = Ideles(K)
            sage: u = J(a, None, {K.prime_above(2): (-a+1, 10)})
            sage: v = J(None, None, {K.prime_above(2): (-a+1, 4), K.prime_above(5): (-a-1, 0)})
            sage: w = J(None, None, {K.prime_above(2): (-a+1, 4), K.prime_above(5): (1/5, 0)})
            sage: u.is_principal()
            False
            sage: v.is_principal()
            True
            sage: w.is_principal()
            False
        """
        K = self.parent().number_field()
        if self.has_exact_finite_part():
            # The only possible ``r`` is ``self.exact_finite_value()``.
            return self._contains(self.exact_finite_value())

        # we are not exact.
        r = K.ideal(1)
        for q, val in self.finite().items():
            x, i = val
            r *= q**(x.valuation(q))
        if not r.is_principal():
            # There does not exist an element of `K` with the right valuations.
            return False
        # The ideal ``r`` is principal, so we can take a generator.
        r = r.gens_reduced()[0]
        # This will be our candidate element of `K` that could lie in ``self``.
        # It is only uniquely determined up to a unit of `K`.
        U = K.unit_group()
        if not U.is_finite():
            raise NotImplementedError("K has infinite unit group, we can't deal with that yet")
        if len(U.gens()) > 1:
            raise NotImplementedError("K has non-cyclic unit group, we can't deal with that yet")
        u = U.gen().value()
        for e in range(U.order()):
            if self._contains(u**e * r):
                return True
        return False
        r"""
        old:
        if all([u_oo is None for u_oo in self.infinite()]):
            # Only finite values stored.
            if K is QQ and len(self.finite()) == 1:
                p = list(self.finite().keys())[0]
                x, i = self.finite(p)
                # The only candidate element is p^e, where:
                e = x.valuation(p)
                # Need to find some `z \in \ZZ_p` such that
                #     `p^e = x*(1+p^i*z)`.
                # Defining:
                y = x / p^e
                # Gives as only option:
                #     `z = (p^e-x)/(x*p^i) = (1-y)/(y*p^i)`
                # which lies in `\QQ`, but we should check that it lies in
                # `\ZZ_p \cap \QQ = \ZZ_{(p)}` (localization at `p`). 
                # That means that the valuation of `z` at `p` should be at least
                # zero. Since the valuation of `y` at `p` is zero, this boils
                # down to:
                return (1-y).valuation(p) >= i
        """

    def equivalent_modulo_principal_ideles(self, v):
        r"""
        Return whether or not `self \equiv v \mod K*`

        INPUT:

        - v -- an idele
        """
        return (self/v).is_principal()


    def increase_precision(self, primes, prec_increment=1):
        """
        Increase the precision of ``self`` at the primes given in ``primes``

        INPUT:

        - ``primes`` -- an iterable containing prime ideals of our number field
          and/or rational prime numbers, or a single prime
        - ``prec_increment`` -- integer (default = 1); the amount by which we
          increase the precision at each prime in ``primes``

        Let `p` be a prime ideal in ``primes``. Suppose ``self`` represents the
        open subset `x * U_p^i` at `p`. Then after calling this method, ``self``
        will represent `x * U_p^(i + prec_increment)` at `p`.

        If `p` in ``primes`` is a rational prime number, then the above is done
        for each prime `q` lying above `p`.

        .. NOTE::

            If ``self`` has an exact known value at a prime `p`, then nothing
            changes. If one sees exactness as having infinite precision, this
            just corresponds to ``oo + prec_increment == oo``.

        .. NOTE::

            Setting ``prec_increment`` to a negative value will decrease the
            precision of ``self``. If the precision drops below zero anywhere,
            we throw an exception.

        EXAMPLE::

            sage: K.<a> = NumberField(x^3-2)
            sage: J = Ideles(K)
            sage: p2 = K.prime_above(2)
            sage: p5 = K.prime_above(5)
            sage: u = J(None, None, {p2: (a, 5), p5: (1/3, 1)})

        Let's increase the precision of ``p2`` and *both* prime ideals above 5
        by 3::

            sage: u.increase_precision([p2, 5], 3)
            sage: u
            Idele with values:
              infinity_0:  RR^*
              infinity_1:  CC^*
              (2, a):       a * U(8)
              (5, a + 2):   1/3 * U(4)
              (5, a^2 - 2*a - 1):   1 * U(3)

        We can also decrease precision::

            sage: u.increase_precision(p2, -1)
            sage: u
            Idele with values:
              infinity_0:  RR^*
              infinity_1:  CC^*
              (2, a):       a * U(7)
              (5, a + 2):   1/3 * U(4)
              (5, a^2 - 2*a - 1):   1 * U(3)

        The precision of exact values is unchanged::
        
            sage: u._exact = a+1
            sage: p3 = K.prime_above(3)
            sage: u.increase_precision([p2, p3, p5])
            sage: u
            Idele with values:
              infinity_0:  RR^*
              infinity_1:  CC^*
              (2, a):       a * U(8)
              (5, a + 2):   1/3 * U(5)
              (5, a^2 - 2*a - 1):   1 * U(3)
              elsewhere:    a + 1
        """
        K = self.parent().number_field()

        if primes in K.ideal_monoid() and K.ideal(primes).is_prime():
            # primes is just a single prime ideal, let's call it p.
            p = ZZ(primes) if K is QQ else K.ideal(primes)
            if p in self.finite():
                x, i = self.finite(p)
            elif self.has_exact_finite_part():
                # We know the value at p exactly, so we don't change
                return
            else:
                x, i = K(1), ZZ(0)
            new_prec = i + prec_increment
            if new_prec < 0:
                raise ValueError("Trying to give idele negative precision")
            self._finite[p] = (x, new_prec)
            return

        if primes in Primes():
            p = primes
            for q in K.primes_above(p):
                self.increase_precision(q, prec_increment)
            return

        for p in primes:
            if p in K.ideal_monoid() and K.ideal(p).is_prime():
                self.increase_precision(p, prec_increment)
            elif p in Primes():
                for q in K.primes_above(p):
                    self.increase_precision(q, prec_increment)
            else:
                raise TypeError("primes should be a list of primes")



class Ideles(UniqueRepresentation, Group):
    Element = Idele

    def __init__(self, K):
        # TODO: implement default K=QQ, via __classcall__()
        from sage.misc.functional import is_field
        if not is_field(K) or not K.absolute_degree() in ZZ:
            raise TypeError("K should be a number field")
        self._number_field = K
        Group.__init__(self, category=Groups().Commutative())

    def _repr_(self):
        """
        Return a string representation of this idèle group

        EXAMPLES::

            sage: K.<a> = NumberField(x^2-3)
            sage: Ideles(K)
            Idele Group of Number Field in a with defining polynomial x^2 - 3
        """
        return "Idele Group of {}".format(self.number_field())

    def _latex_(self):
        r"""
        Return a latex string representation of this idèle group

        EXAMPLES::

            sage: K.<a> = NumberField(x^2-5)
            sage: latex(Ideles(K))
            J_{ \Bold{Q}[a]/(a^{2} - 5) }
        """
        from sage.misc.latex import latex
        return "J_{" + latex(self.number_field()) + "}"

    def _element_constructor_(self, x, y=None):
        if y is None:
            K = self.number_field()
            if x in K:
                infinite = [phi(x) for L, phi in infinite_completions(K)]
                return self.element_class(self, infinite, x)
            from adele import Adeles
            Ak = Adeles(K)
            if x in Ak:
                return self._from_adele(Ak(x))
            if hasattr(x, "parent") and hasattr(x.parent(), "_bnr"):
                # TODO make the check above less hacky and more robust
                # for some reason checking isinstance(x, RayClassGroupElement) fails
                return self._from_ray_class(x)
        return self.element_class(self, x, y)

    def _from_adele(self, adele):
        r"""
        Convert the adele ``adele`` to an idele

        Let U be the subset of the adele ring that ``adele`` represents. Write J
        for the idele group. Then the idele returned represents a subset that
        *contains* `U \cap J`. Note that in general this looses precision.
        TODO: example of precision loss

        EXAMPLES::
            
            sage: from profinite_number import ProfiniteNumbers
            sage: from adele import Adeles
            sage: J = Ideles(QQ)
            sage: A = Adeles(QQ)
            sage: Qhat = ProfiniteNumbers(QQ)
            sage: a = A([-1.5], Qhat(7, 24, 5))
            sage: J._from_adele(a)
            Idele with values:
              infinity_0:   -1.5000000000000000?
              2:            7 * U(3)
              3:            7 * U(1)
            sage: b = A([RIF(-1, 1)], Qhat(5, 25, 2))
            sage: J._from_adele(b)
            Idele with values:
              infinity_0:   0.?
              5:            5 * U(1)
            sage: c = A([pi.n()], 20/3)
            sage: J._from_adele(c)
            Idele with values:
              infinity_0:   3.1415926535897932?
              elsewhere:    20/3

        If the given adele has value zero modulo at one of its stored primes
        (i.e. ``4 mod 12`` has value zero modulo 2^2), then there is no idele
        that represents the adele. For example: the given adele then represents
        multiple element which have different valuation at that prime. But an
        idele always has a unique valuation at every prime. In this case, we
        throw an exception::

            sage: d = A([1], Qhat(4, 12, 3))
            sage: J._from_adele(d)
            Traceback (most recent call last):
            ...
            ValueError: adele is zero at the prime 2
        """
        K = self.number_field()
        value = adele.finite().numerator().value()
        modulus = adele.finite().numerator().modulus()
        denominator = adele.finite().denominator()

        exact = None
        if modulus.is_zero():
            exact = value / denominator
            finite = None
        else:
            x = value
            if K is not QQ:
                x = K.ideal(x)

            finite = {}
            for q, e in factor(modulus):
                v = x.valuation(q)
                if v >= e:
                    # value is zero modulo q^e, which we cannot represent as an
                    # idele
                    raise ValueError("adele is zero at the prime {}".format(q))
                finite[q] = (value, e-v)

        return self.element_class(self, exact, adele.infinite().copy(), finite)

    def _from_ray_class(self, r):
        r"""
        Convert the ray class group element ``r`` to an idele

        INPUT:

        - ``r`` -- a ray class group element

        OUPUT:
        
        Denote the ray class group to which ``r`` belongs by `G` and denote the
        modulus of `G` by `m`. So `G = I(m)/R(m)`.
        Consider the homomorphism `\phi: ` ``self`` `\to` `G` that sends a prime
        element at a finite prime `q` (not dividing `m`) to `q \mod R(m)`.
        The kernel of `\phi` is `K^* W_m` where `W_m = \prod_p U_p^{\ord_p(m)}`.

        Given ``r``, let `H` be the inverse image of ``r`` under `\phi`. We can
        try to find an idele that represents the subset `H` of ``self``. This is
        however not precisely possible. We can exactly represent `W_m`, but 
        we can not represent `K^*`. Hence what we do is the following: we find
        some `x \in H` en return an idele that represents `x \cdot W_m`.

        Although we do always return the same idele for equal inputs, the user
        should be aware that from a mathematical perspective, the output is only
        defined up to multiplication by a principal idele.
        

        EXAMPLES::

            sage: Q = NumberField(x-1, "one")
            sage: J = Ideles(Q)
            sage: G = ray_class_group(Q, Modulus(Q.ideal(10), [0]))
            sage: r = G(Q.ideal(9))
            sage: factor(r.ideal())
            (Fractional ideal (3)) * (Fractional ideal (163))
            sage: J._from_ray_class(r)
            Idele with values:
              infinity_0:   [0.0000000000000000 .. +infinity]
              (2, 0):       1 * U(1)
              (5, 0):       1 * U(1)
              (3, 0):       3 * U(0)
              (163, 0):     163 * U(0)
            sage: s = G(Q.ideal(7))
            sage: s.ideal()
            Fractional ideal (67)
            sage: J._from_ray_class(s)
            Idele with values:
              infinity_0:   [0.0000000000000000 .. +infinity]
              (2, 0):       1 * U(1)
              (5, 0):       1 * U(1)
              (67, 0):      67 * U(0)
           
        :: 

            sage: K.<a> = NumberField(x^2-6)
            sage: G = ray_class_group(K, Modulus(K.ideal(10*a), [1]))
            sage: r = G([3, 0, 1])
            sage: factor(r.ideal())
            (Fractional ideal (25*a + 19)) * (Fractional ideal (28*a - 25)) * (Fractional ideal (-67*a + 109)) * (Fractional ideal (-1507*a - 5011))
            sage: Jk = Ideles(K)
            sage: Jk(r)
            Idele with values:
              infinity_0:  RR^*
              infinity_1:   [0.0000000000000000 .. +infinity]
              (2, a):       1 * U(3)
              (3, a):       1 * U(1)
              (5, a + 1):   1 * U(1)
              (5, a + 4):   1 * U(1)
              (3389, a + 543):      (a + 543) * U(0)
              (4079, a + 2767):     (a - 1312) * U(0)
              (15053, a + 13254):   (a - 1799) * U(0)
              (11483827, a + 1242116):      (a + 1242116) * U(0)
        """
        K = self.number_field()
        G = r.parent()  # ray class group of r
        exact = None
        r1, r2 = K.signature()
        RR = RIF(-oo, oo)
        CC = CIF(RR, RR)
        infinite = [RR for i in range(r1)] + [CC for i in range(r2)]
        for i in G.modulus().infinite_part():
            infinite[i] = RIF(0, oo)

        finite = {}
        for q, e in G.modulus().finite_factors():
            finite[q] = (K(1), e)

        if not r.is_one():
            for q, e in factor(r.ideal()):
                if self.number_field() is QQ:
                    finite[q] = (q**e, ZZ(0))
                else:
                    pi = K.uniformizer(q)
                    finite[q] = (pi**e, ZZ(0))
        
        return self.element_class(self, exact, infinite, finite)

    def cardinality(self):
        return Infinity

    def _coerce_map_from_(self, S):
        if self.number_field().has_coerce_map_from(S):
            return True
        return False

    def number_field(self):
        """
        Return the base number field of ``self``
        """
        return self._number_field

    def _an_element_(self):
        """
        Return a typical element of this group

        EXAMPLE::

            sage: Ideles(QQ).an_element()
            Idele with values:
              infinity_0:   3.1415926535897901?
              2:            3/2 * U(7)
              3:            2 * U(9)
              elsewhere:    -1
            sage: K.<a> = NumberField(x^3-2)
            sage: Ideles(K).an_element()
            Idele with values:
              infinity_0:   1
              infinity_1:   1
              (2, a):       (a + 1) * U(7)
              (3, a + 1):   1/2*a^2 * U(9)
              elsewhere:    -a
        """
        K = self.number_field()
        if K is QQ:
            infinite = [3.14159265358979]
            p2, p3 = ZZ(2), ZZ(3)
        else:
            r1, r2 = K.signature()
            infinite = [i for i in range(1,r1+1)] + [1-i*CIF.gen() for i in range(r2)]
            p2, p3 = K.prime_above(2), K.prime_above(3)
        finite = {
            p2: (1+K.an_element(), 7),
            p3: (1/K.an_element(), 9)
        }
        return self.element_class(self, -K.gens()[-1], infinite, finite)

