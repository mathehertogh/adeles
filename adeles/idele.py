r"""
Idèles of Number Fields

Let `K = \QQ(\alpha)` be the number field generated by `\alpha` over `\QQ`. Let
`O` be the ring of integers of `K`. Define a *finite prime* of `K` to be a prime
ideal of `O`. Define an *infinite prime* of `K` to be an embedding
`\phi: K \to \CC` such that `\phi(\alpha) \geq 0`. By a *prime* of `K` we shall
mean either a finite or an infinite prime of `K`. The set of primes of `K`
corresponds bijectively to the set of equivalence classes of absolute values on
`K`.

For `p` a prime of `K`, write `K_p` for the completion of `K` at `p` and call it
the *field of* `p`-*adic numbers*. We write `O_p` for the ring of `p`-adic
integers, which we define to be `K_p` itself if `p` if infinite.

The *idèle group* `J_K` of `K` is the restricted product `\prod_p' K_p^*` of the
unit groups `K_p^*` with respect to the open subgroups `O_p^*`, where `p` ranges
over all primes of `K`. Concretely, that means

.. MATH::

    J_K = \left\{ (x_p)_p \in \prod_p K_p^* : x_p \in O_p^*
                  \text{ for all but finitely many } p \right\}

This is a multiplicative topological group with component-wise multiplication.
As a group is it equal to the unit group of the adèle ring `\Bold{A}_K`, but not
as a topological group.

We define the *finite idèle group* `J_K^0` of `K` to be the same restricted
prodcut `\prod_p' K_p^*` but with `p` ranging over the finite primes only.

Let `(r,s)` be the signature of `K`. Similar to what we did for adèles, we view
the idèle group as

.. MATH::

    J_K = \prod_{i=1}^r \RR^* \times \prod_{j=1}^s \CC^* \times J_K^0

where the order of the real and complex fields is given by ``K.places()``.

This leads us to let an :class:`Idele` consist of a pair `u = (x, y)` where

- `x` is called the *infinite part* of `u` and is list with `r+s` entries, the
  first `r` of which are non-zero elements of ``RIF`` and the last `s` of of
  which are non-zero elements of ``CIF``;
- `y` is called the *finite part* of `u` and is either an element of `K^*` or is
  a dictionary with finite primes of `K` as values such that the value at a
  finite prime `p` is a multiplicative `p`-adic over `K`.

::

    sage: K.<a> = NumberField(x^2-3)
    sage: J = Ideles(K); J
    Idele Group of Number Field in a with defining polynomial x^2 - 3
    sage: u = J([-1, 9.7], {a: (a+1, 20), 5: (1/10*a, 20)}); u
    Idèle with values:
      infinity_0:   -1
      infinity_1:   9.6999999999999993?
      (3, a):       (a + 1) * U(20)
      (5):          1/10*a * U(20)
      other primes: 1 * U(0)
    sage: u.infinite_part()
    [-1, 9.6999999999999993?]
    sage: u.finite_part()
    {Fractional ideal (a): (a + 1) * U(20), Fractional ideal (5): 1/10*a * U(20)}

Above we created an ``Idele`` ``u`` whose finite part is a dictionary. The keys
are the prime ideals above `3` and `5`. We call primes stored as keys in the
finite part of an ``Idele`` the *stored primes*::

    sage: u.stored_primes()
    [Fractional ideal (a), Fractional ideal (5)]

We can get the multiplicative `p`-adic that we stored for a stored prime `p` by
indexing the ``Idele``::

    sage: u[a]
    (a + 1) * U(20)
    sage: u[5]
    1/10*a * U(20)
    sage: u[a].parent()
    Group of multiplicative (3, a)-adics of Number Field in a with defining polynomial x^2 - 3

We can even ask for a multiplicative `p`-adic for finite primes `p` of `K` which
are not stored::

    sage: p7 = K.prime_above(7)
    sage: u[p7]
    1 * U(0)
    sage: u[p7].parent()
    Group of multiplicative (7)-adics of Number Field in a with defining polynomial x^2 - 3

This always returns a multiplicative `p`-adic representing `O_p^*`.

And we can also ask the individual values in the infinite part of `u` by
indexing::

    sage: u[oo, 0]
    -1
    sage: u[oo, 1]
    9.6999999999999993?

The *represented subset* of an ``Idele`` `u` with finite part a dictionary is
given by

.. MATH::

    \prod_{i=1}^{r+s} (R(u[\infty, i]) \setminus \{0\}) \times \prod_{p \in S} R(u[p]) \times \prod_{p \not\in S} O_p^*

where the last product ranges over the finite primes of `K` not in `S` and

- `u[\infty, i]` denotes the `i`-th entry of the infinite part of `u`;
- `R(u[\infty, i])` denotes the real or complex interval that `u[\infty, i]`
  represents;
- `S` denotes the set of stored primes of `u`;
- `u[p]` denotes the multiplicative `p`-adic stored at `p`;
- `R(u[p])` denotes the represented subset of `u[p]` (which is a subset of
  `K_p^*`).


We can also create an ``Idele`` whose finite part is an element of `K^*`::

    sage: v = J([7.9, 4], a/3); v
    Idèle with values:
      infinity_0:   7.9000000000000004?
      infinity_1:   4
      other primes: 1/3*a
    sage: v.finite_part()
    1/3*a
    sage: v.finite_part().parent()
    Number Field in a with defining polynomial x^2 - 3

We say that an ``Idele`` whose finite part lies in `K^*` *has exact finite
part*. ::

    sage: u.has_exact_finite_part()
    False
    sage: v.has_exact_finite_part()
    True

This terminology comes from the fact that an ``Idele`` `v` that has exact finite
part has *represented subset*

.. MATH::

    \prod_{i=1}^{r+s} (R(v[\infty, i]) \setminus \{0\}) \times \prod_p \{v_0\}

where `p` ranges over all finite primes of `K` and `v_0 \in K^*` denotes the
finite part of `v`.

We can still index ``v`` by finite primes of `K`. ::

    sage: v[5]
    1/3*a
    sage: v[5].parent()
    Group of multiplicative (5)-adics of Number Field in a with defining polynomial x^2 - 3

We can perform arithmetic with idèles. ::

    sage: u * v
    Idèle with values:
      infinity_0:   -7.9000000000000004?
      infinity_1:   38.799999999999998?
      (3, a):       (1/3*a + 1) * U(20)
      (5):          1/10 * U(20)
      other primes: 1 * U(0)
    sage: u / v
    Idèle with values:
      infinity_0:   -0.1265822784810127?
      infinity_1:   2.4249999999999999?
      (3, a):       (a + 3) * U(20)
      (5):          3/10 * U(20)
      other primes: 1 * U(0)

We can ask an ``Idele`` its valuation at a finite prime of `K`. ::

    sage: u.valuation(5)
    -1
    sage: u.valuation(K.prime_above(97))
    0

The natural (diagonal) embedding `K^* \to J_K` is implemented as a conversion.
::

    sage: J(a)
    Idèle with values:
      infinity_0:   -1.732050807568878?
      infinity_1:   1.732050807568878?
      other primes: a

A basis of the topology on `J_K^0` is given by the sets

.. MATH::

    \prod_{p \in S} V_p \times \prod_{p \not\in S} O_p^*

where `S` is a finite set of finite primes of `K` and each `V_p` is an open
subset of `K_p^*`. Let the *finite represented subset* of an ``Idele`` be the
projection of its represented subset to `J_K^0`. We can approximate any
`\alpha \in J_K^0` arbitrarily closely by an ``Idele`` in the following sense:
for any neighborhood `U` of `\alpha` in `J_K^0`, the exists an ``Idele`` whose
finite represented subset contains `\alpha` and is contained in `U`.

.. SEEALSO::

    :mod:`~adeles.multiplicative_padic`,
    :mod:`~adeles.adele`

REFERENCES:

[Her2021] Mathé Hertogh, Computing with adèles and idèles, master's thesis,
Leiden University, 2021.

This implementation of idèles is based on [Her2021]. An extensive exposition of
properties, design choices and two applications can be found there.

AUTHORS:

- Mathé Hertogh (2021-07): initial version based on [Her2021]
"""

# ****************************************************************************
#       Copyright (C) 2021 Mathé Hertogh <m.c.hertogh@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.structure.element import MultiplicativeGroupElement
from sage.structure.unique_representation import UniqueRepresentation
from sage.groups.group import Group
from sage.categories.groups import Groups
from sage.arith.misc import factor
from sage.rings.integer_ring import ZZ
from sage.rings.rational_field import QQ
from sage.rings.real_mpfi import RIF
from sage.all import RR, CC
from sage.rings.complex_interval_field import ComplexIntervalField
from sage.rings.infinity import Infinity
from sage.sets.primes import Primes
from sage.arith.functions import lcm

from .completion import infinite_completions
from .multiplicative_padic import is_finite_prime, MulPAdic, MultiplicativePAdics
from .ray_class_group import Modulus, ray_class_group, RayClassGroupElement

CIF = ComplexIntervalField()
oo = Infinity


class Idele(MultiplicativeGroupElement):
    r"""
    Idèle over a Number Field

    REFERENCES:

    Section 3.6 of [Her2021].

    .. automethod:: __init__

    .. automethod:: __getitem__

    .. automethod:: _mul_

    .. automethod:: _div_

    .. automethod:: _richcmp_
    """

    def __init__(self, parent, infinite, finite):
        r"""
        Construct an idèle

        INPUT:

        - ``parent`` -- an idèle group of some number field `K`; the parent
        - ``infinite`` -- a list of length `r+s` (for `(r,s)` the signature of
          `K`) whose first `r` entries lie in ``RIF`` and whose last `s` entries
          lie in ``CIF`` and none of whose entries equals zero.
          If `r+s=1`, then we also accept a single non-zero element in
          ``RIF``/``CIF``.
        - ``finite`` -- a non-zero element of `K` or a dictionary with keys
          finite primes of `K` (as specified by
          :func:`~adeles.multiplicative_padic.is_finite_prime`) such that the
          value at `p` is (data to construct) a multiplicative `p`-adic.

        EXAMPLES:

        We begin with the easiest case: `K = \QQ`::

            sage: J = Ideles(QQ)
            sage: Idele(J, 3.14, {2: (5/3, 2), 5: (1, 9)})
            Idèle with values:
              infinity_0:   3.1400000000000002?
              2:            5/3 * U(2)
              5:            1 * U(9)
              other primes: 1 * U(0)
            sage: Idele(J, RIF(-1.122, -1.119), 1/3)
            Idèle with values:
              infinity_0:   -1.12?
              other primes: 1/3
            sage: Idele(J, RIF(-oo, oo), {7: (1/7, 0)})
            Idèle with values:
              infinity_0:   RR^*
              7:            1/7 * U(0)
              other primes: 1 * U(0)

        Now let's take a non-trivial number field::

            sage: K.<a> = NumberField(x^4-17)
            sage: Jk = Ideles(K)
            sage: p3, p7 = K.prime_above(3), K.prime_above(7)
            sage: Idele(Jk, [3.14, -1, 1+I], {p3: (a^3, 7), p7: (a^2, 4)})
            Idèle with values:
              infinity_0:   3.1400000000000002?
              infinity_1:   -1
              infinity_2:   1 + 1*I
              (3, 1/2*a^2 - a - 1/2):       a^3 * U(7)
              (7, 1/2*a^2 + a - 5/2):       a^2 * U(4)
              other primes: 1 * U(0)
            sage: Idele(Jk, [RIF(7.8, 7.9), -1, I], a^3-a^2+2*a-5)
            Idèle with values:
              infinity_0:   8.?
              infinity_1:   -1
              infinity_2:   1*I
              other primes: a^3 - a^2 + 2*a - 5

        TESTS::

            sage: Idele(J, [1], 0)
            Traceback (most recent call last):
            ...
            ValueError: exact finite value must be non-zero
            sage: Idele(J, [1], "blah")
            Traceback (most recent call last):
            ...
            TypeError: finite must be a dictionary or a non-zero number field element
        """
        MultiplicativeGroupElement.__init__(self, parent)

        self._infinite = infinite
        self._validate_infinite()

        self._finite = finite
        self._validate_finite()

    def __getitem__(self, prime):
        """
        Get the value of this idèle at the prime ``prime``

        INPUT:

        - ``prime`` - a prime of our base number field `K`, which can be:

          - a finite prime of `K`, as specified by
            :func:`~adeles.multiplicative_padic.is_finite_prime`;
          - an infinite prime of `K` in the form of a pair ``(Infinity, i)``
            where ``i`` is a non-negative integer specifying the index of the
            infinite prime;

          If `K` ony has one infinite prime, then we also accept ``Infinity``
          and interpret it as ``(Infinity, 0)``.

        OUTPUT:

        The value of this idèle at ``prime``. If ``prime`` is a finite prime,
        then this is a multiplicative ``prime``-adic. If ``prime`` is
        ``(Infinity, i)``, then this is an element of ``RIF`` or ``CIF``.

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J(3.1, {2: (1,2)})
            sage: u[oo]
            3.1000000000000001?
            sage: u[2]
            1 * U(2)
            sage: u[3]
            1 * U(0)

        ::

            sage: K.<a> = NumberField(x^5-3)
            sage: Jk = Ideles(K)
            sage: v = Jk([-1.5, -I, 1+I], {K.prime_above(3): (a, 4)})
            sage: v[oo, 0]
            -1.5000000000000000?
            sage: v[oo, 2]
            1 + 1*I
            sage: v[K.prime_above(3)]
            a * U(4)

        We may throw the following exceptions::

            sage: u[oo, 5]
            Traceback (most recent call last):
            ...
            IndexError: list index out of range
            sage: v[2] # the ideal (2) is not prime in K
            Traceback (most recent call last):
            ...
            KeyError: 'You can only index by a finite prime or (Infinity, index)'
        """
        K = self.parent().number_field()
        if is_finite_prime(prime, K):
            prime = ZZ(prime) if K is QQ else K.ideal(prime)
            if self.has_exact_finite_part():
                return MulPAdic(prime, self.finite_part())
            try:
                return self.finite_part()[prime]
            except KeyError:
                return MulPAdic(prime, (K(1), ZZ(0)))
        if prime is Infinity and len(self.infinite_part()) == 1:
            return self.infinite_part()[0]
        try:
            inf, index = prime
            if inf is Infinity:
                return self.infinite_part()[index]
        except TypeError:
            pass
        raise KeyError("You can only index by a finite prime or (Infinity, index)")

    def _repr_(self):
        """
        Return a representation of this idèle.

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J(RIF(-oo, oo), {97: (7/9, 20)}); u
            Idèle with values:
              infinity_0:       RR^*
              97:               7/9 * U(20)
              other primes:     1 * U(0)
            sage: v = J([-7.123456], 5/8); v
            Idèle with values:
              infinity_0:   -7.1234560000000001?
              other primes: 5/8
        """
        K = self.parent().number_field()
        rep = "Idèle with values:"

        RR = RIF(-oo, oo)
        CC = CIF(RR, RR)
        for i in range(len(self.infinite_part())):
            x_i = self[oo, i]
            if x_i.endpoints() == RR.endpoints():
                rep += "\n  infinity_{}:\tRR^*".format(i)
            elif x_i.endpoints() == CC.endpoints():
                rep += "\n  infinity_{}:\tCC^*".format(i)
            else:
                rep += "\n  infinity_{}:\t{}".format(i, x_i)

        for P in self.stored_primes():
            P_name = self[P].parent().prime_name()
            tab = "\t\t" if len(P_name) < 5 else "\t"
            rep += "\n  {}:{}{}".format(P_name, tab, self[P])

        if self.has_exact_finite_part():
            rep += "\n  other primes:\t{}".format(self.finite_part())
        else:
            rep += "\n  other primes:\t1 * U(0)"

        return rep

    def _mul_(self, other):
        """
        Return the product of this idèle and ``other``

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J(-1, {2: (1/2, 7), 3: (2/5, 8)}); u
            Idèle with values:
              infinity_0:   -1
              2:            1/2 * U(7)
              3:            2/5 * U(8)
              other primes: 1 * U(0)
            sage: v = J(2.5, {3: (-1, 4)}); v
            Idèle with values:
              infinity_0:   2.5000000000000000?
              3:            80 * U(4)
              other primes: 1 * U(0)
            sage: u * v
            Idèle with values:
              infinity_0:   -2.5000000000000000?
              2:            1/2 * U(0)
              3:            32 * U(4)
              other primes: 1 * U(0)

        ::

            sage: K.<a> = NumberField(x^3-2)
            sage: J = Ideles(K)
            sage: u = J([1, 1], {a+1: (-a^2/2, 3), 7: (1/3, 0)}); u
            Idèle with values:
              infinity_0:   1
              infinity_1:   1
              (3, a + 1):   -1/2*a^2 * U(3)
              (7):          1/3 * U(0)
              other primes: 1 * U(0)
            sage: J(a) * u
            Idèle with values:
              infinity_0:   1.259921049894873?
              infinity_1:   -0.62996052494743671? + 1.0911236359717214?*I
              (2, a):       a * U(0)
              (3, a + 1):   -1 * U(3)
              (7):          1/3*a * U(0)
              other primes: 1 * U(0)

        REFERENCES:

        Section Arithmetic in Section 3.6 of [Her2021].
        """
        # At the infinite primes we perform component-wise multiplication.
        infinite = [self[oo, i] * other[oo, i] for i in range(len(self.infinite_part()))]

        if self.has_exact_finite_part() and other.has_exact_finite_part():
            finite = self.finite_part() * other.finite_part()
        elif not self.has_exact_finite_part() and not other.has_exact_finite_part():
            stored_primes = set(self.stored_primes() + other.stored_primes())
            finite = dict([(P, self[P]*other[P]) for P in stored_primes])
        else:
            if not self.has_exact_finite_part():
                self, other = other, self
            # Now self has exact finite part while other does not.
            stored_primes = set(self.finite_part().support() + other.stored_primes())
            finite = dict([(P, self[P]*other[P]) for P in stored_primes])

        return self.__class__(self.parent(), infinite, finite)

    def _div_(self, other):
        """
        Return the quotient of this idèle by ``other``

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J(3.0, {3: (1/3, 6), 7: (2, 1)})
            sage: v = J(2.0, {3: (3, 4), 5: (50, 1)})
            sage: u / v
            Idèle with values:
              infinity_0:   1.5000000000000000?
              3:            1/9 * U(4)
              5:            1/50 * U(0)
              7:            2 * U(0)
              other primes: 1 * U(0)
            sage: v / u
            Idèle with values:
              infinity_0:   0.6666666666666667?
              3:            9 * U(4)
              5:            50 * U(0)
              7:            1/2 * U(0)
              other primes: 1 * U(0)
            sage: u / J(11/2)
            Idèle with values:
              infinity_0:   0.545454545454546?
              2:            2/11 * U(0)
              3:            2/33 * U(6)
              7:            4/11 * U(1)
              11:           2/11 * U(0)
              other primes: 1 * U(0)

        ::

            sage: K.<i> = NumberField(x^2+1)
            sage: J = Ideles(K)
            sage: u = J(2*I, {i+1: (i, 10), 3: (i/3, 10)})
            sage: u / J(i)
            Idèle with values:
              infinity_0:   2
              (2, i + 1):   1 * U(10)
              (3):          1/3 * U(10)
              other primes: 1 * U(0)
            sage: v = J(-1.25, {3: (2, 8), 7: (2*i+1, 12)})
            sage: u / v
            Idèle with values:
              infinity_0:   -1.600000000000000?*I
              (2, i + 1):   i * U(0)
              (3):          1/6*i * U(8)
              (7):          (-2/5*i + 1/5) * U(0)
              other primes: 1 * U(0)

        REFERENCES:

        Section Arithmetic in Section 3.6 of [Her2021].
        """
        return self * other.inverse()

    def _richcmp_(self, other, op):
        """
        Return the result of operator ``op`` applied to ``self`` and ``other``

        Only equality and inequality are implented.

        We declare ``self`` and ``other`` equal if their represented subsets
        have non-empty intersection.

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: J(1, 1) == J(RIF(0, 2), 1)
            True
            sage: J(1, 1) != J(RIF(-7, -5), 1)
            True

        The represented subsets do *not* contain zero at infinite primes::

            sage: J(RIF(-oo, 1), 1) == J(RIF(1, oo), 1) # intersection is {1}
            True
            sage: J(RIF(-oo, 0), 1) == J(RIF(0, oo), 1) # intersection is empty (not {0})
            False

        ::

            sage: J(1, 1) != J(1, 1/2)
            True
            sage: J(1, -1) == J(1, {2: (-1, 4)})
            True
            sage: J(1, 15) != J(1, {2: (-1, 4)})
            True

        ::

            sage: J(1, {2: (4, 0)}) == J(1, {2: (4, 5)})
            True
            sage: J(1, {2: (4, 0)}) == J(1, {2: (2, 5)})
            False
            sage: J(1, {2: (4, 0)}) == J(1, {97: (1, 0)})
            False

        REFERENCES:

        Section 5.4 of [Her2021].
        """
        from sage.structure.richcmp import op_EQ, op_NE

        if op == op_EQ:
            # First we check that we have non-empty intersection of represented
            # subsets at all infinite primes.
            for i in range(len(self.infinite_part())):
                try:
                    intersection = self[oo, i].intersection(other[oo, i])
                except ValueError:
                    # This indicates the intersection is empty
                    return False
                if intersection.is_zero():
                    # Zero does *not* lie in the represented subsets!
                    return False
            
            # At the infinite parts we are "equal". Now the finite parts.

            if self.has_exact_finite_part() and other.has_exact_finite_part():
                return self.finite_part() == other.finite_part()

            if not self.has_exact_finite_part() and not other.has_exact_finite_part():
                stored_primes = set(self.stored_primes() + other.stored_primes())
                return all([self[P] == other[P] for P in stored_primes])

            # Only self or only other has exact finite part. Let's make sure it
            # is other.
            if self.has_exact_finite_part():
                self, other = other, self

            primes_to_check = set(self.stored_primes() + other.finite_part().support())
            return all([self[P] == other[P] for P in primes_to_check])

        if op == op_NE:
            return not (self == other)

        raise NotImplementedError("only (in)equality implemented for idèles")

    def _validate_infinite(self):
        """
        Validate the infinite part of this idèle

        Denote the signature of our base number field by `(r,s)`. Then our
        finite part should be a list of length `r+s` with the first `r` entries
        non-zero elements of `RIF` and the last `s` entries non-zero elements of
        ``CIF``. If the entries do lie in these interval fields, but do not have
        them as their parents, we convert them.

        We raise an exception if our infinite part is invalid.

        EXAMPLES:

        We look at a number field with one real and one complex prime::

            sage: K.<a> = NumberField(x^3 + x + 1)
            sage: Jk = Ideles(K)
            sage: u = Jk(1)
            sage: u._infinite = [int(3), I]
            sage: u._validate_infinite()

        The Python integer ``3`` and the Gaussian integer ``I`` have now been
        converted so elements of ``RIF`` and ``CIF`` respectively::

            sage: u[oo, 0].parent()
            Real Interval Field with 53 bits of precision
            sage: u[oo, 1].parent()
            Complex Interval Field with 53 bits of precision

        The exceptions that we may throw:

            sage: u._infinite = [3.14, I, I]
            sage: u._validate_infinite()
            Traceback (most recent call last):
            ...
            ValueError: infinite must have length 2
            sage: u._infinite = None
            sage: u._validate_infinite()
            Traceback (most recent call last):
            ...
            TypeError: infinite must be a list
            sage: u._infinite = [I, I]
            sage: u._validate_infinite()
            Traceback (most recent call last):
            ...
            TypeError: 0th infinite value (I) must be a non-zero element of Real Interval Field with 53 bits of precision
            sage: u._infinite = [1, CIF(0)]
            sage: u._validate_infinite()
            Traceback (most recent call last):
            ...
            ValueError: 1th infinite value (0) must be a non-zero element of Complex Interval Field with 53 bits of precision
        """
        K = self.parent().number_field()
        K_oo = infinite_completions(K, fields_only=True)

        if len(K_oo) == 1 and (self._infinite in K_oo[0] or
                                (K_oo[0] is RIF and self._infinite in RR) or
                                (K_oo[0] is CIF and self._infinite in CC)):
            self._infinite = [self._infinite]
        else:
            try:
                self._infinite = list(self._infinite)
            except TypeError:
                raise TypeError("infinite must be a list")
        
        if len(self._infinite) != len(K_oo):
            raise ValueError("infinite must have length {}".format(len(K_oo)))

        for i in range(len(K_oo)):
            val = self._infinite[i]
            if (not (val in K_oo[i] or (K_oo[i] is RIF and val in RR)
                    or (K_oo[i] is CIF and val in CC)) or val == 0):
                raise TypeError("{}th infinite value ({}) must be a non-zero element of {}".format(i, val, K_oo[i]))
            self._infinite[i] = K_oo[i](val)

    def _validate_finite(self):
        r"""
        Validate the finite part of this idèle

        Our finite part should be an non-zero element of our base number field
        `K`, or a dictionary with finite primes of `K` (cf.
        :func:`~adeles.multiplicative_padic.is_finite_prime`) as keys and with
        value at `p` a multiplicative `p`-adic.

        If the data can be converted to the correct type/parent, then we do
        that. If this is not possible, we raise an exception.

        EXAMPLES::

            sage: K.<a> = NumberField(x^4+x+1)
            sage: J = Ideles(K)
            sage: u = J(1)
            sage: u._finite = {a+3: (3, 1)}
            sage: u._validate_finite()
            sage: u.finite_part()
            {Fractional ideal (a + 3): 35*a^3 * U(1)}
        
        Above ``a+3`` was turned into an ideal and ``(3, 1)`` was turned into
        the corresponding multiplicative ``(a+3)``-adic ``35*a^3 * U(1)``.

        The exceptions that we may throw are the following::

            sage: u._finite = 0
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            ValueError: exact finite value must be non-zero
            sage: u._finite = ["blah"]
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            TypeError: finite must be a dictionary or a non-zero number field element

        Keys must be primes of K. Although 5 is a prime number, it is not a
        prime of `K` as 5 splits into two primes in `K`::

            sage: u._finite = {5: (1, 1)}
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            TypeError: keys of the dictionary must be finite primes

        Values are checked for correctness as well::

            sage: u._finite = {K.prime_above(2): (1, -1)}
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            ValueError: prec must be a non-negative integer or Infinity
            sage: u._finite = {K.prime_above(2): ([], 3)}
            sage: u._validate_finite()
            Traceback (most recent call last):
            ...
            ValueError: center must lie in K^*
        """
        K = self.parent().number_field()

        if self._finite in K:
            if self._finite == 0:
                raise ValueError("exact finite value must be non-zero")
            self._finite = K(self._finite)
        elif isinstance(self._finite, dict):
            # We will replace self._finite will our own dictionary ``finite`` in
            # which we ensure all keys and values have the correct parents.
            finite = {}
            for P, data in self._finite.items():
                if not is_finite_prime(P, K):
                    raise TypeError("keys of the dictionary must be finite primes")
                P = ZZ(P) if K is QQ else K.ideal(P)
                finite[P] = MulPAdic(P, data)

            self._finite = finite
        else:
            raise TypeError("finite must be a dictionary or a non-zero number field element")

    def inverse(self):
        """
        Return the inverse of this idèle
        
        EXAMPLES::

            sage: K.<a> = NumberField(x^2-2)
            sage: J = Ideles(K)
            sage: J([2, 3], a/2).inverse()
            Idèle with values:
              infinity_0:   0.50000000000000000?
              infinity_1:   0.3333333333333334?
              other primes: a
            sage: J([-1, 1/4], {a: (a, 3), 3: (-1, 5)}).inverse()
            Idèle with values:
              infinity_0:   -1
              infinity_1:   4
              (2, a):       1/2*a * U(3)
              (3):          -1 * U(5)
              other primes: 1 * U(0)

        REFERENCES:

        Section Arithmetic in Section 3.6 of [Her2021].
        """
        infinite = self.infinite_part().copy()
        for i in range(len(infinite)):
            infinite[i] = 1 / infinite[i]

        if self.has_exact_finite_part():
            finite = 1 / self.finite_part()
        else:
            finite = {P: self[P].inverse() for P in self.stored_primes()}

        return self.__class__(self.parent(), infinite, finite)

    def infinite_part(self):
        """
        Return the infinite part of this idèle

        EXAMPLES::

            sage: K.<a> = NumberField(x^5-3*x+1)
            sage: J = Ideles(K)
            sage: u = J([-1, 7.9, 1, 1+I], a^2)
            sage: u.infinite_part()
            [-1, 7.9000000000000004?, 1, 1 + 1*I]
        """
        return self._infinite

    def finite_part(self):
        """
        Return the finite part of this idèle

        This could be either a number field element or a dictionary.

        EXAMPLES::

            sage: K.<a> = NumberField(x^5-3*x+1)
            sage: J = Ideles(K)
            sage: u = J([1, 1, 1, 1], a^2)
            sage: u.finite_part()
            a^2
            sage: p3, q3 = K.primes_above(3)
            sage: v = J([1, 1, 1, 1], {p3: (a, 10), q3: (-1-a^2, 7)})
            sage: v.finite_part()
            {Fractional ideal (-a^2 + 1): -11107*a^4 * U(10),
             Fractional ideal (-2*a^4 - a^3 - 2*a^2 - a + 4): (-920*a^4 - 31*a^3 - 90*a^2 - 961*a) * U(7)}
        """
        return self._finite

    def stored_primes(self):
        r"""
        Return the set of stored primes of this idèle as an ordered list.

        A stored prime is a finite prime of the base number field `K` for which
        this idèle has stored a value in its finite part.

        If this idèle has exact finite part, then it has no stored primes.
        
        The order is determined by the implemented order on number field ideals,
        or by the natural order on `\NN` if `K = \QQ` (in which case the primes
        are prime numbers).

        EXAMPLES::

            sage: K.<a> = NumberField(x^2+17)
            sage: J = Ideles(K)
            sage: p2, p5 = K.prime_above(2), K.prime_above(5)
            sage: p7, q7 = K.primes_above(7)
            sage: u = J(I, {q7: (a, 1), p2: (8, 0), p7: (1,0), p5: (a, 3)})
            sage: u.stored_primes()
            [Fractional ideal (2, a + 1),
             Fractional ideal (5),
             Fractional ideal (7, a + 2),
             Fractional ideal (7, a + 5)]

        ::

            sage: v = J(-1, a+1)
            sage: v.stored_primes()
            []
        """
        if self.has_exact_finite_part():
            return []
        return sorted(list(self.finite_part().keys()))

    def valuation(self, prime):
        r"""
        Return the valuation of this idèle at the finite prime ``prime``

        INPUT:

        - ``prime`` -- a finite prime of our base number field, as described by
          :func:`~adeles.multiplicative_padic.is_finite_prime`

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J([1], 1/25)
            sage: u.valuation(2)
            0
            sage: u.valuation(5)
            -2
            sage: v = J([1], {2: (8, 10)})
            sage: v.valuation(2)
            3
            sage: v.valuation(3)
            0

        ::

            sage: K.<a> = NumberField(x^2+5)
            sage: J = Ideles(K)
            sage: p3, q3 = K.primes_above(3)
            sage: u = J([I], {p3: (3, 0)})
            sage: u.valuation(p3)
            1
            sage: u.valuation(q3)
            0

        TESTS::

            sage: Q.<one> = NumberField(x-1)
            sage: J = Ideles(Q)
            sage: u = J([-1], {7: (7^20, 3)})
            sage: u.valuation(Q.prime_above(7))
            20
        """
        if self.has_exact_finite_part():
            return self.finite_part().valuation(prime)
        return self[prime].valuation()

    def ideal(self):
        r"""
        Return the fractional ideal with the same valuations as this idèle
        
        OUTPUT: 

        The fractional ideal `I` of our base field `K` such that `I` has the
        same valuation as this idèle at every finite prime of `K` if `K \neq
        \QQ`. If `K = \QQ`, then we return the rational number that has the same
        valuations as this idèle at every prime number.

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: J(9/7).ideal()
            9/7
            sage: u = J(3.1415, {2: (3, 2), 5: (1/5, 0)})
            sage: u.ideal()
            1/5

        ::

            sage: K.<a> = NumberField(x^2+5)
            sage: Jk = Ideles(K)
            sage: Jk(a-1).ideal()
            Fractional ideal (a - 1)
            sage: p2 = K.prime_above(2)
            sage: p3, q3 = K.primes_above(3)
            sage: v = Jk(-1, {p2: (4, 3), p3: (3, 10), q3: (1/6, 20)})
            sage: I = v.ideal(); I
            Fractional ideal (4/3*a - 8/3)
            sage: all([I.valuation(p) == v.valuation(p) for p in K.primes_of_bounded_norm(50)])
            True
        """
        if self.has_exact_finite_part():
            K = self.parent().number_field()
            if K is QQ:
                return self.finite_part()
            else:
                return K.ideal(self.finite_part())
        else:
            from sage.misc.misc_c import prod
            return prod([p**self.valuation(p) for p in self.stored_primes()])

    def has_exact_finite_part(self):
        """
        Return whether or not this idèle has exact finite part

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u = J(-1, 7)
            sage: u.has_exact_finite_part()
            True
            sage: v = J(-1, {2: (1, 1)})
            sage: v.has_exact_finite_part()
            False
        """
        return self._finite in self.parent().number_field()

    def is_integral(self):
        """
        Return whether or not this idèle is integral

        Integral means that its valuation at each finite prime of our base field
        is non-negative.
        
        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: J(1, 3).is_integral()
            True
            sage: J(1, 1/3).is_integral()
            False
            sage: J(1, {2: (1/3, 10)}).is_integral()
            True
            sage: J(1, {2: (1/2, 10)}).is_integral()
            False
        """
        if self.has_exact_finite_part():
            O = self.parent().number_field().maximal_order()
            return self.finite_part() in O
        return all([self[P].valuation() >= 0 for P in self.stored_primes()])

    def is_very_integral(self):
        """
        Return whether or not this idèle is very integral

        An idèle `u` is called *very integral* if at each finite prime `p` of
        the base number field `K`, the center of `u[p]` is an integral element
        of `K`.
        
        This is stronger than `u` being integral (see the examples below).
        
        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: J(1, 5).is_very_integral()
            True
            sage: J(1, 1/5).is_very_integral()
            False
            sage: J(1, {2: (10, 0)}).is_very_integral()
            True
            sage: J(1, {2: (1/10, 0)}).is_very_integral()
            False

        Being very integral is stronger than being integral::

            sage: u = J(1, {3: (1/2, 3)})
            sage: u.is_integral()
            True
            sage: u.is_very_integral()
            False

        REFERENCES:

        Section 4.3 of [Her2021].
        """
        O = self.parent().number_field().maximal_order()
        if self.has_exact_finite_part():
            return self.finite_part() in O
        return all([self[P].center() in O for P in self.stored_primes()])

    def very_integral_split(self):
        """
        Split this idèle into a very integral idèle and a denominator

        OUTPUT:

        A pair `(u, d)` where `u` is a very integral idèle and `d` is a positive
        integer such that this idèle equals `u/d`.

        .. SEEALSO::

            :meth:`is_very_intergral`

        EXAMPLES::

            sage: J = Ideles(QQ)
            sage: u, d = J(1, 1/4).very_integral_split(); u, d
            (Idèle with values:
               infinity_0:  4
               other primes:        1,
             4)
            sage: u/J(d)
            Idèle with values:
              infinity_0:   1
              other primes: 1/4

        ::

            sage: K.<a> = NumberField(x^2-5)
            sage: J = Ideles(K)
            sage: u = J([2, -1], {2: (a, 3), 3: (a/5, 1), a: (1/7, 0)}); u
            Idèle with values:
              infinity_0:   2
              infinity_1:   -1
              (2):          a * U(3)
              (3):          1/5*a * U(1)
              (5, 1/2*a + 5/2):     1/7 * U(0)
              other primes: 1 * U(0)
            sage: v, d = u.very_integral_split()
            sage: d
            35
            sage: v
            Idèle with values:
              infinity_0:   70
              infinity_1:   -35
              (2):          3*a * U(3)
              (3):          a * U(1)
              (5, 1/2*a + 5/2):     (5*a + 5) * U(0)
              (7):          (49/2*a + 21/2) * U(0)
              other primes: 1 * U(0)
            sage: u == v/J(d)
            True
        """
        from sage.arith.functions import lcm
        K = self.parent().number_field()

        if self.has_exact_finite_part():
            d = self.finite_part().denominator()
        else:
            d = lcm([self[P].center().denominator() for P in self.stored_primes()])

        return (self.parent()(d)*self, d)

    def increase_precision(self, primes, prec_increment=1):
        """
        Increase the precision of this idèle at the primes given in ``primes``

        INPUT:

        - ``primes`` -- an iterable containing finite primes and/or (rational)
          prime numbers, or a single prime
        - ``prec_increment`` -- integer (default = 1); the amount by which we
          increase the precision at each prime in ``primes``

        Write `K` for our base number field. Let `p` be a finite prime of `K` in
        ``primes``. Increasing the precision of ``self`` at `p` will increase
        the precision of ``self[p]`` by ``prec_increment``, while making sure
        that ``self[p]`` still represents the original center of ``self[p]``.

        If `p` in ``primes`` is a rational prime number, then the above is done
        for each prime `q` lying above `p` with ``prec_increment`` multiplied
        by the ramification index of `q` over `p`.

        .. NOTE::

            If this idèle has exact finite part, then this method does not do
            anything. If one sees exactness as having infinite precision, this
            just corresponds to ``oo + prec_increment == oo``.

        .. NOTE::

            Setting ``prec_increment`` to a negative value will decrease the
            precision, but not below zero.

        EXAMPLE::

            sage: K.<a> = NumberField(x^3-2)
            sage: J = Ideles(K)
            sage: p2, p5 = K.prime_above(2), K.prime_above(5)
            sage: u = J([1, I], {p2: (a, 5), p5: (1/3, 1)})

        Let's increase the precision of ``p2`` and *both* prime ideals above 5
        by 3::

            sage: u.increase_precision([p2, 5], 3); u
            Idèle with values:
              infinity_0:   1
              infinity_1:   1*I
              (2, a):       a * U(8)
              (5, a^2 - 2*a - 1):   (a^2 - 2*a) * U(3)
              (5, a + 2):   1/3 * U(4)
              other primes: 1 * U(0)

        We can also decrease precision::

            sage: u.increase_precision(p2, -1); u
            Idèle with values:
              infinity_0:   1
              infinity_1:   1*I
              (2, a):       a * U(7)
              (5, a^2 - 2*a - 1):   (a^2 - 2*a) * U(3)
              (5, a + 2):   1/3 * U(4)
              other primes: 1 * U(0)

        As ``p2`` has ramification index 3, the following will increase the
        precision of ``u`` at ``p2`` by 3::

            sage: u.increase_precision(2); u
            Idèle with values:
              infinity_0:   1
              infinity_1:   1*I
              (2, a):       a * U(13)
              (5, a^2 - 2*a - 1):   (a^2 - 2*a) * U(3)
              (5, a + 2):   1/3 * U(4)
              other primes: 1 * U(0)

        Nothing changes for idèles with exact finite part::
        
            sage: v = J([2, 2*I], a^2)
            sage: v.increase_precision([p2, p5]); v
            Idèle with values:
              infinity_0:   2
              infinity_1:   2*I
              other primes: a^2

        REFERENCES:

        Section 9.3.1 of [Her2021].

        TESTS::

            sage: u.increase_precision([QQ])
            Traceback (most recent call last):
            ...
            ValueError: primes should be a (list of) prime(s)
        """
        if self.has_exact_finite_part():
            return

        K = self.parent().number_field()

        if is_finite_prime(primes, K):
            P = ZZ(primes) if K is QQ else K.ideal(primes)
            new_prec = max(ZZ(0), self[P].prec() + prec_increment)
            self._finite[P] = MulPAdic(P, (self[P].center(), new_prec))
            return

        if primes in Primes():
            p = primes # primes is a single rational prime number
            for P in K.primes_above(p):
                self.increase_precision(P, prec_increment*P.ramification_index())
            return

        for prime in primes:
            if not (is_finite_prime(prime, K) or prime in Primes()):
                raise ValueError("primes should be a (list of) prime(s)")
            self.increase_precision(prime, prec_increment)

    def to_ray_class(self, modulus):
        r"""
        Return the image of this idèle in the ray class group modulo ``modulus``

        This idèle must have enough precision to have a well-defined image in
        the ray class group modulo ``modulus``. This means that (1) for each
        infinite prime `p` dividing ``modulus``, the real interval that this
        idèle represents at `p` lies in eithe `\RR_{<0}` or `\RR_{>0}` and (2)
        that for each finite prime `p` dividing ``modulus``, the precision of
        ``self[p]`` is at least the valuation of ``modulus`` at `p`.

        INPUT:

        - ``modulus`` -- a :class:`~adeles.ray_class_group.Modulus` of `K`

        .. WARNING::

            The ray class group of ``QQ`` is not implemented. To use this
            functionality over `\QQ`, use the isormophic number field
            ``NumberField(x-1)``, as in the examples below.

        EXAMPLES::

            sage: Q = NumberField(x-1, "one")
            sage: J = Ideles(Q)
            sage: u = J(-9.0, {2: (10, 1), 3: (3, 2), 7: (1/2, 4)})
            sage: m = Modulus(Q.ideal(18), [0])
            sage: u.to_ray_class(m).ideal()
            Fractional ideal (7)

        ::

            sage: K.<a> = NumberField(x^3-x-1)
            sage: Jk = Ideles(K)
            sage: p7, q7 = K.primes_above(7)
            sage: u = Jk([2, I], {p7: (1/2, 1), q7: (7*a, 2)})
            sage: m = Modulus(K.ideal(7), [0])
            sage: u.to_ray_class(m).ideal()
            Fractional ideal (2*a^2 - a + 3)

        TESTS::

            sage: K = NumberField(x^2 + 5*x - 3, 'a')
            sage: J = Ideles(K)
            sage: G = ray_class_group(K, Modulus(K.ideal(14), [0])); G
            Ray class group of order 18 with structure C6 x C3 of Number Field in a with defining polynomial x^2 + 5*x - 3 of modulus (Fractional ideal (14)) * infinity_0
            sage: c0, c1 = G.gens()
            sage: for e in range(6):
            ....:     for f in range(3):
            ....:         r = c0^e * c1^f
            ....:         assert G(J(r)) == r, "bug!"  # long time

        ALGORITHM:

        We construct an idèle `v` satisfying:
            - `v \equiv self \mod K^*`
            - `v \equiv 1 \mod^* modulus`

        We do this by starting of with `v =` ``self`` and then improve `v` in
        three steps:

            1. Make `v` integral at the primes dividing ``modulus``.
            2. Make `v \equiv 1 \mod^*` ``modulus.finite_part()``
            3. Make `v \equiv 1 \mod^*` ``modulus`` (fix the infinite part)

        In every step we only change `v` by multiplying it with principal idèles
        (i.e. elements of K^*) as to never violate the first desired condition
        on `v`.
        For Step 2 we use the number field version of the Chinese Remainder
        Theorem (cf. :func:`solve_CRT`). For Step 3 we use
        :meth:`~adeles.ray_class_group.Modulus.get_one_mod_star_finite_with_fixed_signs`.

        Once we have such a `v`, we return the image of the ideal
        `\prod_{p} p^{ord_p(v)}` in ``G``, where `p` ranges over the stored
        primes of `v`.

        REFERENCES:

        Section 4.5 of [Her2021].
        """
        if self.has_exact_finite_part():
            finite = {q : (self.finite_part(), e) for q, e in modulus.finite_factors()}
            return self.parent()(self.infinite_part(), finite).to_ray_class(modulus)

        J = self.parent()
        K = J.number_field()
        G = ray_class_group(K, modulus)

        # First we check if the precision of this idèle is high enough to have
        # a well-defined image in the ray class group `G`.
        for i in modulus.infinite_part():
            if not (self[oo, i] <= 0 or self[oo, i] >= 0):
                raise ValueError("idèle has no well-defined sign at {}-th infinite prime".format(i))
        for q, e in modulus.finite_factors():
            if self[q].precision() < e:
                raise ValueError("idèle must have precision at least {} at q={}".format(e, q))

        v = self
        # Step 1. We make `v` integral at the primes dividing modulus.
        for q, e in modulus.finite_factors():
            c = self[q].center()
            if c not in K.maximal_order():
                v *= J(c.denominator())

        # Step 2. We find an element `y` in the maximal order `O_K` of `K` such
        # that `y \equiv v \mod modulus.finite_part()` using the Chinese
        # Remainder Theorem.
        values = []
        moduli = []
        for q, e in modulus.finite_factors():
            f = v[q].valuation() + v[q].precision()
            # Note that at each of these primes `q` we have
            #     `1 <= modulus.valuation(q) <= v[q].precision()`
            # and so the represented subset of `v` at `q` is
            #     `v[q].center() + q^f O_q`.
            values.append(v[q].center())
            moduli.append(q**f)
        y = K.solve_CRT(values, moduli)
        if not y.is_zero():
            # `y` is zero if and only if `values` and `moduli` are empty.
            # In that case we can just leave v as it is.
            v /= J(y)
        # Now we have `v \equiv 1 \mod^* modulus.finite_part()`.
        
        # Step 3. We address the infinite part using the Modulus-method
        # get_one_mod_star_finite_with_fixed_signs().
        positive = []
        negative = []
        for i in modulus.infinite_part():
            if v[oo, i] >= 0:
                positive.append(i)
            else:
                negative.append(i)
        t = modulus.get_one_mod_star_finite_with_fixed_signs(positive, negative)
        v *= J(t)
        # Now we have `v \equiv 1 \mod^* modulus`.

        # Our `v` is finished. We can now build up an ideal representing the
        # image of `v` (which is equal to the image of ``self``) in ``G``.
        I = v.ideal()
        return G(I)


class Ideles(UniqueRepresentation, Group):
    """
    Idèle Group of a Number Field

    REFERENCES:

    Section 3.6 of [Her2021].

    .. automethod:: _element_constructor_
    """

    Element = Idele

    def __classcall__(cls, K=QQ):
        """
        Construct the idèle group of the number field `K`

        INPUT:

        - ``K`` -- a number field (default: ``QQ``)

        EXAMPLES::

            sage: Ideles(QQ)
            Idèle Group of Rational Field

        This method ensures that the following returns ``True``::

            sage: Ideles() is Ideles(QQ)
            True

        TESTS::

            sage: Ideles("not a number field")
            Traceback (most recent call last):
            ...
            TypeError: K should be a number field
        """
        from sage.rings.number_field.number_field import is_NumberField
        if not is_NumberField(K):
                raise TypeError("K should be a number field")
        return super(Ideles, cls).__classcall__(cls, K)

    def __init__(self, K):
        r"""
        Construct the idèle group of the number field ``K``

        INPUT:

        - ``K`` -- a number field (default: `\QQ`)

        EXAMPLES::

            sage: Ideles()
            Idèle Group of Rational Field
            sage: K.<a> = NumberField(x^5-3*x+1)
            sage: Ideles(K)
            Idèle Group of Number Field in a with defining polynomial x^5 - 3*x + 1
        """
        # Input verification is done by __classcall__().
        self._number_field = K
        Group.__init__(self, category=Groups().Commutative())

    def _repr_(self):
        """
        Return a string representation of this idèle group

        EXAMPLES::

            sage: K.<a> = NumberField(x^2-3)
            sage: Ideles(K)
            Idèle Group of Number Field in a with defining polynomial x^2 - 3
        """
        return "Idèle Group of {}".format(self.number_field())

    def _latex_(self):
        r"""
        Return a latex string representation of this idèle group

        EXAMPLES::

            sage: K.<a> = NumberField(x^2-5)
            sage: latex(Ideles(K))
            J_{ \Bold{Q}[a]/(a^{2} - 5) }
        """
        from sage.misc.latex import latex
        return "J_{" + latex(self.number_field()) + "}"

    def _element_constructor_(self, x, y=None):
        r"""
        Construct an idèle

        INPUT:

        Denote our base number field by `K` and its signature by `(r, s)`. The
        standard format to construct an idèle is giving two variables:

        - ``infinite`` -- a list of length `r+s` whose first `r` values lie in
          ``RIF`` and whose last `s` values lie in ``CIF``; the infinite part
        - ``finite`` -- either a non-zero element of `K` or a dictionary with
          keys finite primes of `K` (cf.
          :func:`~adeles.multiplicative_padic.is_finite_prime`) such that the
          value at a finite prime `p` is (data to construct) a multiplicative
          `p`-adic; the finite part.

        One can also give one of the following objects:

        - a non-zero element of `K`; create the corresponding principal idèle
        - an element of `(O/I)^*`, for `O` the maximal order of `K` and `I` an
          `O`-ideal; see :meth:`_from_modulo_element`
        - a ray class group element; see :meth:`_from_ray_class` 

        EXAMPLES:

        We start by constructing idèles over `\QQ` in the standard manner. ::

            sage: J = Ideles(QQ)
            sage: J(5.4321, 1/7)
            Idèle with values:
              infinity_0:   5.4321000000000002?
              other primes: 1/7
            sage: J(-1.5, {2: (1/2, 0), 3: (4, 2), 17: (-1, 1), 31: (1/5, 10)})
            Idèle with values:
              infinity_0:   -1.5000000000000000?
              2:            1/2 * U(0)
              3:            4 * U(2)
              17:           16 * U(1)
              31:           1/5 * U(10)
              other primes: 1 * U(0)

        Next we will create idèles over `\QQ(\sqrt{3})`. ::

            sage: K.<a> = NumberField(x^2-3)
            sage: J = Ideles(K)

        We start by specifying the infinite and finite parts::

            sage: J([-7.9, 9.7], 1/2*a+5)
            Idèle with values:
              infinity_0:   -7.9000000000000004?
              infinity_1:   9.6999999999999993?
              other primes: 1/2*a + 5
            sage: J([pi.n(), e.n()], {a+1: (16, 3), a: (1/6, 0), 5: (-1, 10)})
            Idèle with values:
              infinity_0:   3.1415926535897932?
              infinity_1:   2.7182818284590451?
              (2, a + 1):   16 * U(3)
              (3, a):       1/6 * U(0)
              (5):          -1 * U(10)
              other primes: 1 * U(0)
        
        We convert the square root ``a`` of `3` to an idèle::

            sage: J(a)
            Idèle with values:
              infinity_0:   -1.732050807568878?
              infinity_1:   1.732050807568878?
              other primes: a

        We construct an idèle from `a+2 + 8a^3O_K \in (O_K/8a^3O_K)^*`::

            sage: O = K.maximal_order()
            sage: Q = O.quotient(8*a^3, 'b')
            sage: J(Q(a+2))
            Idèle with values:
              infinity_0:   RR^*
              infinity_1:   RR^*
              (2, a + 1):   (a + 2) * U(6)
              (3, a):       (a + 2) * U(3)
              other primes: 1 * U(0)

        And lastly we create an idèle from a ray class group element. ::

            sage: G = ray_class_group(K, Modulus(K.ideal(5), [1]))
            sage: J(G.gen())
            Idèle with values:
              infinity_0:   RR^*
              infinity_1:   [0.0000000000000000 .. +infinity]
              (3, a):       a * U(0)
              (5):          1 * U(1)
              other primes: 1 * U(0)

        .. automethod:: _from_modulo_element
        .. automethod:: _from_ray_class
        """
        if y is None:
            # Conversion based on the inclusion of `K^*` in this idèle group.
            K = self.number_field()
            if x in K and x != 0:
                infinite = [phi(x) for phi in infinite_completions(K, embeddings_only=True)]
                return self.element_class(self, infinite, x)

            # Conversion from (O/I)^* to this idèle group
            from sage.rings.quotient_ring import is_QuotientRing
            P = x.parent() if hasattr(x, "parent") else None
            O = K.maximal_order()
            if is_QuotientRing(P) and P.ambient() in [O, K]:
                if K.ideal(x.lift()) + P.defining_ideal() != 1:
                    raise ValueError("{} is not a unit modulo {}".format(x, P.defining_ideal()))
                return self._from_modulo_element(x)

            # Conversion from ray class groups to this idèle group.
            if isinstance(x, RayClassGroupElement):
                return self._from_ray_class(x)

        return self.element_class(self, x, y)

    def _from_modulo_element(self, x):
        """
        Create an idèle from an element of `(O/I)^*`, with `O` the maximal order
        of our base field and `I` an `O`-ideal

        EXAMPLES::

            sage: J = Ideles()
            sage: J._from_modulo_element(Zmod(100)(7))
            Idèle with values:
              infinity_0:   RR^*
              2:            3 * U(2)
              5:            7 * U(2)
              other primes: 1 * U(0)
            sage: J._from_modulo_element(Zmod(1024 * 27)(97))
            Idèle with values:
              infinity_0:   RR^*
              2:            97 * U(10)
              3:            16 * U(3)
              other primes: 1 * U(0)

        ::

            sage: K.<a> = NumberField(x^3-7)
            sage: J = Ideles(K)
            sage: O = K.maximal_order()
            sage: Q = O.quotient(5*a^5, 'b')
            sage: J._from_modulo_element(Q(a+1))
            Idèle with values:
              infinity_0:   RR^*
              infinity_1:   CC^*
              (5, a^2 - 2*a - 1):   (a^2 - a) * U(1)
              (5, a + 2):   a^2 * U(1)
              (7, a):       (a + 1) * U(5)
              other primes: 1 * U(0)

        REFERENCES:

        Section 4.2 of [Her2021].
        """
        K = self.number_field()
        r, s = K.signature()
        RR = RIF(-oo, oo)
        CC = CIF(RR, RR)
        infinite = [RR for i in range(r)] + [CC for i in range(s)] 

        I = x.parent().defining_ideal()
        if K is QQ:
            I = I.gen()
        finite = {}
        for P, e in I.factor():
            finite[P] = (x.lift(), e)

        return self.element_class(self, infinite, finite)

    def _from_ray_class(self, r):
        r"""
        Convert the ray class group element ``r`` to an idèle
        
        Denote the ray class group to which ``r`` belongs by `G` and denote this
        idèle group by `J`. This method implements a section of the natural
        homomorphism `\phi: J \to G`.

        INPUT:

        - ``r`` -- a ray class group element

        OUPUT:

        An idèle whose represented subset is contained in the inverse image of
        ``r`` under `\phi`.
        
        EXAMPLES::

            sage: Q = NumberField(x-1, "one")
            sage: J = Ideles(Q)
            sage: G = ray_class_group(Q, Modulus(Q.ideal(10), [0]))
            sage: r = G(Q.ideal(7))
            sage: r.ideal()
            Fractional ideal (67)
            sage: J._from_ray_class(r)
            Idèle with values:
              infinity_0:   [0.0000000000000000 .. +infinity]
              (2):          1 * U(1)
              (5):          1 * U(1)
              (67):         67 * U(0)
              other primes: 1 * U(0)
            sage: s = G(Q.ideal(9))
            sage: factor(s.ideal())
            (Fractional ideal (3)) * (Fractional ideal (163))
            sage: J._from_ray_class(s)
            Idèle with values:
              infinity_0:   [0.0000000000000000 .. +infinity]
              (2):          1 * U(1)
              (3):          3 * U(0)
              (5):          1 * U(1)
              (163):        163 * U(0)
              other primes: 1 * U(0)
           
        :: 

            sage: K.<a> = NumberField(x^2-6)
            sage: G = ray_class_group(K, Modulus(K.ideal(10*a), [1]))
            sage: r = G([3, 0, 1])
            sage: [P.gens_two() for P in r.ideal().prime_factors()]
            [(3389, a + 543),
             (4079, a + 2767),
             (15053, a + 13254),
             (11483827, a + 1242116)]
            sage: Ideles(K)(r)
            Idèle with values:
              infinity_0:   RR^*
              infinity_1:   [0.0000000000000000 .. +infinity]
              (2, a):       1 * U(3)
              (3, a):       1 * U(1)
              (5, a + 1):   -a * U(1)
              (5, a + 4):   a * U(1)
              (3389, a + 543):      2846760*a * U(0)
              (4079, a + 2767):     -2916485*a * U(0)
              (15053, a + 13254):   -94683370*a * U(0)
              (11483827, a + 1242116):      -22108284774109*a * U(0)
              other primes: 1 * U(0)

        REFERENCES:

        Section 4.5 of [Her2021].
        """
        K = self.number_field()
        G = r.parent()  # ray class group of r
        r1, r2 = K.signature()
        RR = RIF(-oo, oo)
        CC = CIF(RR, RR)
        infinite = [RR for i in range(r1)] + [CC for i in range(r2)]
        for i in G.modulus().infinite_part():
            infinite[i] = RIF(0, oo)

        finite = {}
        for q, e in G.modulus().finite_factors():
            finite[q] = (K(1), e)

        if not r.is_one():
            for q, e in factor(r.ideal()):
                if self.number_field() is QQ:
                    finite[q] = (q**e, ZZ(0))
                else:
                    pi = K.uniformizer(q)
                    finite[q] = (pi**e, ZZ(0))
        
        return self.element_class(self, infinite, finite)

    def _an_element_(self):
        """
        Return a typical element of this idèle group

        EXAMPLES::

            sage: Ideles().an_element()
            Idèle with values:
              infinity_0:   1.1000000000000001?
              2:            1/2 * U(0)
              5:            1 * U(4)
              7:            6 * U(1)
              other primes: 1 * U(0)

        ::

            sage: K.<a> = NumberField(x^5-3)
            sage: Ideles(K).an_element()
            Idèle with values:
              infinity_0:   1.1000000000000001?
              infinity_1:   1*I
              infinity_2:   -1*I
              (2, a + 1):   1/2 * U(0)
              (5, a + 2):   a * U(4)
              (7, a + 2):   -1/3*a^4 * U(1)
              other primes: 1 * U(0)
        """
        K = self.number_field()
        r, s = K.signature()
        infinite = [i/10 for i in range(11, 11+r)] + [CIF.gen()*(-1)**i for i in range(s)]
        p2 = 2 if K is QQ else K.prime_above(2)
        p5 = 5 if K is QQ else K.prime_above(5)
        p7 = 7 if K is QQ else K.prime_above(7)
        finite = {p2: (ZZ(1)/2, 0), p5: (K.gen(), 4), p7: (-1/K.gen(), 1)}
        return self.element_class(self, infinite, finite)

    def some_elements(self):
        """
        Return some elements of this idèle group
        
        EXAMPLES::

            sage: K.<a> = NumberField(x^3-3)
            sage: Ideles(K).some_elements()
            [Idèle with values:
               infinity_0:  1
               infinity_1:  1
               other primes:        1,
             Idèle with values:
               infinity_0:  1.1000000000000001?
               infinity_1:  1*I
               (2, a + 1):  1/2 * U(0)
               (5, a - 2):  -227*a^2 * U(4)
               (7):         -1/3*a^2 * U(1)
               other primes:        1 * U(0),
             Idèle with values:
               infinity_0:  -1.442249570307409?
               infinity_1:  0.72112478515370416? - 1.2490247664834065?*I
               other primes:        -a,
             Idèle with values:
               infinity_0:  0.3666666666666667?
               infinity_1:  0.3333333333333334?*I
               (2, a + 1):  1/6 * U(0)
               (3, a):      1/3 * U(0)
               (5, a - 2):  -227/3*a^2 * U(4)
               (7):         -1/9*a^2 * U(1)
               other primes:        1 * U(0)]
        """
        K = self.number_field()
        return [self(1), self.an_element(), self(-K.gen()), self.an_element()/self(3)]

    def random_element(self):
        """
        Return a random element of this idèle group

        EXAMPLES::

            sage: K.<a> = CyclotomicField(7)
            sage: [Ideles(K).random_element() for i in range(3)] # random
            [Idèle with values:
               infinity_0:  -0.51975171438300394? - 0.67367014750726840?*I
               infinity_1:  -0.85107695762543690? - 0.36389292097382331?*I
               infinity_2:  0.35558791902846210? - 0.68617671826900418?*I
               (2, a^3 + a + 1):    (1/2*a^5 + 1/13*a^4 - 2/5*a^2 - 1/3*a - 1/12) * U(2)
               (2, a^3 + a^2 + 1):  (-6*a^5 - 7*a^4 + 4*a^3 + 5/26*a^2 + 1/13) * U(5)
               (3):         -61*a^5 + 1/5*a^2 + 1/3
               (5):         1/2*a^5 - a^4 + 3*a^3 + a^2 + a + 1
               (29, a + 4): (2*a^5 + 1/2*a^3) * U(1)
               (29, a + 13):        (-589/3*a^5 + 1/2*a^3 - 1/3) * U(2)
               (71, a + 23):        (89/4*a^5 + 4/39*a^4) * U(1)
               (14183891, a - 5143802):     (-286578*a^5 + 3/8*a^2) * U(1)
               other primes:        1 * U(0),
             Idèle with values:
               infinity_0:  0.17867179666343170? - 0.14359113026337789?*I
               infinity_1:  -0.0056081648383310423? - 0.72504509402939422?*I
               infinity_2:  0.65035239845213578? - 0.76425573918357848?*I
               (2, a^3 + a + 1):    (1/2*a^4 + 1/3*a^2) * U(1)
               (2, a^3 + a^2 + 1):  (417*a^5 - 143/9*a^4 - 17*a^3 - 1/11) * U(8)
               (3):         (1/7*a^5 - 1/2*a^3 + 3/2*a^2 - 4*a - 1) * U(17)
               (127, a - 16):       (-13610448578379057367615*a^5 + 1/5*a^2 + 1/2*a - 1/3) * U(11)
               (14939, a + 3745):   (-1586328428659*a^5 - 1/7*a^3 - 1/3*a^2) * U(3)
               (1608209, a + 681759):       -a^5 * U(1)
               other primes:        1 * U(0),
             Idèle with values:
               infinity_0:  -0.79630434007873397? + 0.036877119019420591?*I
               infinity_1:  0.86806032709460435? + 0.96171997458908343?*I
               infinity_2:  0.73364936718846652? + 0.18087036068983698?*I
               (2, a^3 + a + 1):    (2*a^5 - 3/8*a^4 - a^3) * U(5)
               (2, a^3 + a^2 + 1):  (a^5 + a^3) * U(1)
               (29, a + 5): (69/8*a^5 + 1/2*a^2 + 1/5*a) * U(0)
               (29, a + 6): (-116687219*a^5 + 1/13*a^4) * U(6)
               (4943, a - 144):     -a^5 - 3*a^4 - 2/5*a^2 + a + 1/2
               other primes:        1 * U(0)]
        """
        K = self.number_field()
        r, s = K.signature()
        infinite = [RIF.random_element() for i in range(r)] + [CIF.random_element() for i in range(s)]

        if K is QQ:
            I = ZZ.random_element()
            while I in [0, -1]:
                I = ZZ.random_element()
        else:
            I = K.ideal(K.random_element())

        if I == 1:
            finite = K.random_element()
            while finite == 0:
                finite = K.random_element()
        else:
            finite = {P: MultiplicativePAdics(K, P).random_element() for P in I.prime_factors()}

        return self.element_class(self, infinite, finite)

    def gens(self):
        """
        Return a tuple of generators of this group, which is ``(1,)``

        EXAMPLES::

            sage: Ideles(QQ).gens()
            (1,)
        """
        return (self(1), )

    def gen(self, n=0):
        """
        Return the ``n``-th generator of this group

        As this group has only one generator, we only accept ``n == 0``.

        INPUT:

        - ``n`` -- the index of the generator to return (default: ``0``); must
          be zero

        EXAMPLES::

            sage: Ideles(QQ).gen()
            1
            sage: Ideles(CyclotomicField(7)).gen(0)
            1

        TESTS::

            sage: Ideles(QQ).gen(1)
            Traceback (most recent call last):
            ...
            IndexError: n must be 0
        """
        if n == 0:
            return self(1)
        else:
            raise IndexError("n must be 0")

    def ngens(self):
        """
        Return the number of generators of this group, which is `1`

        EXAMPLES::

            sage: Ideles().ngens()
            1
        """
        return ZZ(1)

    def is_abelian(self):
        """
        Return ``True``, indicating that this group is abelian

        EXAMPLES::

            sage: Ideles().is_abelian()
            True
        """
        return True

    def is_commutative(self):
        """
        Return ``True``, indicating that this group is commutative

        EXAMPLES::

            sage: Ideles().is_commutative()
            True
        """
        return True

    def is_exact(self):
        """
        Return ``False``, indicating that doing arithmetic can lead to precision
        loss

        EXAMPLES::

            sage: Ideles().is_exact()
            False
        """
        return False

    def is_finite(self):
        """
        Return ``False``, indicating that this group is not finite

        EXAMPLES::

            sage: Ideles().is_finite()
            False
        """
        return False

    def order(self):
        """
        Return the order of this group, which is ``Infinity``

        The order of a group is its number of elements.

        EXAMPLES::

            sage: Ideles().order()
            +Infinity
        """
        return Infinity

    def number_field(self):
        """
        Return the base number field of this idèle group

        EXAMPLES::

            sage: K.<a> = NumberField(x^7-1000*x+1)
            sage: J = Ideles(K)
            sage: J.number_field()
            Number Field in a with defining polynomial x^7 - 1000*x + 1
        """
        return self._number_field

