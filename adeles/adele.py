r"""
Adèles of Number Fields

Let `K = \QQ(\alpha)` be the number field generated by `\alpha` over `\QQ`. Let
`O` be the ring of integers of `K`. We define a *finite prime* of `K` to be a
prime ideal of `O`. An *infinite prime* of `K` is an embedding `\phi: K \to \CC`
such that `\phi(\alpha) \geq 0`. By a *prime* of `K` we shall mean either a
finite or an infinite prime of `K`.

The set of primes of `K` corresponds bijectively to the set of equivalence
classes of absolute values on `K`. For `p` a prime of `K`, we let the field of
`p`-adic numbers be the completion of `K` with respect to a corresponding
absolute value and we denote it by `K_p`.

For `p` a finite prime of `K`, we denote the (normalized) valuation on `K_p` by
`ord_p: K_p \to \ZZ \cup \{\infty\}`, setting `ord_p(0) = \infty`. We denote
the corresponding valuation ring by `O_p` and call it the ring of `p`-adic
integers. For `p` an infinite prime of `K` we set `O_p = K_p`.

The *adèle ring* `\Bold{A}_K` of `K` is usually defined as the restricted
product `\prod_p' K_p` with `p` ranging over all primes of `K` and the
restricted product taken with respect to the open subrings `O_p`. Concretely,
that means

.. MATH::

    \Bold{A}_K = \left\{ (x_p)_p \in \prod_p K_p : x_p \in O_p
                  \text{ for all but finitely many } p \right\}

Let `(r,s)` denote the signature of `K`. We will view `\Bold{A}_K` as the ring

.. MATH::

    \Bold{A}_K = \prod_{i=1}^r \RR \times \prod_{j=1}^s \CC \times \hat{K}

where the infinite primes of `K` are ordered according to ``K.places()`` and
the ring of profinite `K`-numbers `\hat{K}` is identified with the finite adèle
ring in the natural way (cf. [Her2021] Section 3.4).

This point of view leads us to define a `K`-adèle in SageMath to consist out of
an *infinite part* and a *finite part*; the infinite part is a list of length
`r+s`, where the first `r` entries are ``RealInterval`` instances and the last
`s` entries are ``ComplexInterval`` instances and the finite part is a profinite
`K`-number. The *represented subset* of such an adèle `((x_1, ..., x_{r+s}), y)`
is given by

.. MATH::

    \prod_{i=1}^{r+s} R(x_i) \times R(y)

where `R(x_i)` denotes the interval in `\RR` or `\CC` that `x_i` represents and
`R(y)` denotes the represented subset in `\hat{K}` of `y`.

Examples with `\QQ`-adèles
--------------------------

Let's create the adèle ring of `\QQ`::

    sage: A = Adeles(QQ); A
    Adèle Ring of Rational Field

And let's create some adèles::

    sage: a = A(3.14, Qhat(1/3, 14)); a
    (3.1400000000000002?, 1/3 mod 14)
    sage: b = A(1.5, Qhat(2, 6)); b
    (1.5000000000000000?, 2 mod 6)
    sage: c = A(-1, -1); c
    (-1, -1)

As you can see, the adèles are printed using their infinite and finite parts. ::

    sage: a.infinite_part()
    [3.1400000000000002?]
    sage: a.finite_part()
    1/3 mod 14

Arithmetic is done component-wise::

    sage: a + b
    (4.640000000000000?, 1/3 mod 2)
    sage: a - c
    (4.140000000000000?, 4/3 mod 14)
    sage: b * a
    (4.710000000000000?, 2/3 mod 2)
    sage: a / c
    (-3.1400000000000002?, 41/3 mod 14)

We can ask the projections of our adèle to various `p`-adic fields, as well as
`\RR`::

    sage: a[2]
    1 + O(2)
    sage: a[3]
    3^-1 + O(3^0)
    sage: a[5]
    O(5^0)
    sage: a[7]
    5 + O(7)
    sage: a[oo]
    3.1400000000000002?

We can also create adèles over `\QQ` using `p`-adic numbers::

    sage: d_2 = Qp(2)(3, 3); d_2
    1 + 2 + O(2^3)
    sage: d_3 = Qp(3)(1/6, 2); d_3
    2*3^-1 + 1 + 3 + O(3^2)
    sage: d_5 = Qp(5)(1/50, -1); d_5
    3*5^-2 + O(5^-1)
    sage: d = A([9.7, d_2, d_3, d_5]); d
    (9.6999999999999993?, 809/75 mod 72/5)
    sage: d[2]
    1 + 2 + O(2^3)
    sage: d[3]
    2*3^-1 + 1 + 3 + O(3^2)
    sage: d[5]
    3*5^-2 + O(5^-1)
    sage: d[7]
    O(7^0)

This `p`-adic functionality is however only available for adèles over `\QQ`, not
for `K`-adèles for `K` a non-trivial number field. This is because SageMath
currently does not have an implementation of `p`-adic numbers for `p` finite
primes of number fields in general.

Adèles over Number Fields
-------------------------

Let's create a non-trivial number field and the corresponding adèle ring. ::

    sage: K.<a> = NumberField(x^5 - x^3 - 2*x + 1)
    sage: Khat = ProfiniteNumbers(K)
    sage: Ak = Adeles(K); Ak
    Adèle Ring of Number Field in a with defining polynomial x^5 - x^3 - 2*x + 1
    sage: K.signature()
    (3, 1)

The signature of `K` is `(3, 1)`, hence we need three reals and one complex
number for our `K`-adèles::

    sage: b = Ak([-1, 1, 2, 4*I], Khat(a, 100/3)); b
    (-1, 1, 2, 4*I, a mod (100/3))

The order of the `\RR`'s and `\CC`'s is given by ``K.places()``::

    sage: K.places()
    [Ring morphism:
       From: Number Field in a with defining polynomial x^5 - x^3 - 2*x + 1
       To:   Real Field with 106 bits of precision
       Defn: a |--> -1.486472477019139559485881355066,
     Ring morphism:
       From: Number Field in a with defining polynomial x^5 - x^3 - 2*x + 1
       To:   Real Field with 106 bits of precision
       Defn: a |--> 0.4613519931561143817091321992793,
     Ring morphism:
       From: Number Field in a with defining polynomial x^5 - x^3 - 2*x + 1
       To:   Real Field with 106 bits of precision
       Defn: a |--> 1.311334219189466694020034823301,
     Ring morphism:
       From: Number Field in a with defining polynomial x^5 - x^3 - 2*x + 1
       To:   Complex Field with 53 bits of precision
       Defn: a |--> -0.143106867663221 + 1.04474941303801*I]

Hence under the natural (diagonal) embedding `K \to \Bold{A}_K`, the generator
``a`` of `K` maps to the following `K`-adèle::

    sage: Ak(a)
    (-1.486472477019140?, 0.4613519931561144?, 1.311334219189467?, -0.14310686766322076? + 1.0447494130380122?*I, a)

The above conversion defines a coercion and hence we can do::

    sage: a + b
    (-2.486472477019140?, 1.461351993156115?, 3.311334219189467?, -0.14310686766322076? + 5.0447494130380122?*I, 2*a mod (100/3))
    sage: a * b
    (1.486472477019140?, 0.4613519931561144?, 2.622668438378934?, -4.1789976521520487? - 0.57242747065288302?*I, a^2 mod (100/3*a))

.. SEEALSO::

    :mod:`~adeles.profinite_number`,
    :mod:`~adeles.multiplicative_padic`,
    :mod:`~adeles.idele`

REFERENCES:

[Her2021] Mathé Hertogh, Computing with adèles and idèles, master's thesis,
Leiden University, 2021.

This implementation of adèles is based on [Her2021]. An extensive exposition of
properties, design choices and two applications can be found there.

AUTHORS:

- Mathé Hertogh (2021-07): initial version based on [Her2021]
"""

# ****************************************************************************
#       Copyright (C) 2021 Mathé Hertogh <m.c.hertogh@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.categories.rings import Rings
from sage.categories.number_fields import NumberFields
from sage.categories.pushout import ConstructionFunctor
from sage.structure.unique_representation import UniqueRepresentation
from sage.structure.element import CommutativeAlgebraElement
from sage.rings.ring import CommutativeAlgebra
from sage.categories.homset import Hom
from sage.sets.primes import Primes
from sage.all import ComplexField, RR
from sage.rings.complex_interval_field import ComplexIntervalField
from sage.rings.real_mpfi import RIF
from sage.rings.integer_ring import ZZ
from sage.rings.rational_field import QQ
from sage.rings.infinity import Infinity

from .profinite_integer import ProfiniteIntegers
from .profinite_number import ProfiniteNumbers, ProfiniteNumber
from .completion import infinite_completions
from .idele import Idele

CC = ComplexField()
CIF = ComplexIntervalField()
oo = Infinity


class Adele(CommutativeAlgebraElement):
    """
    Adèle over a Number Field

    REFERENCES:

    Section 3.4 of [Her2021].

    .. automethod:: __init__

    .. automethod:: __getitem__

    .. automethod:: _add_

    .. automethod:: _sub_

    .. automethod:: _mul_

    .. automethod:: _div_

    .. automethod:: _richcmp_
    """

    def __init__(self, parent, infinite, finite):
        r"""
        Construct the adèle determined by ``infinite`` and ``finite``

        INPUT:

        - ``parent`` -- an adèle ring of some number field `K`
        - ``infinite`` -- a list of elements in real/complex interval fields;
          denoting the signature of `K` by `(r,s)`, the list must have length
          `r+s`, the first `r` entries must be elements of ``RealIntervalField``
          and the last `s` entries must be elements of ``ComplexIntervalField``.
          If `K` has a unique infinite prime, then we also accept an element of
          ``RIF`` or ``CIF``, depending on whether the prime is real or complex.
        - ``finite`` -- a profinite number over `K`

        OUTPUT:

        An adèle with infinite part given by ``infinite`` and finite part given
        by ``finite``. 

        EXAMPLES::

            sage: A = Adeles(QQ)
            sage: Adele(A, 3.14, 7)
            (3.1400000000000002?, 7)
            sage: Qhat = ProfiniteNumbers(QQ)
            sage: Adele(A, 7.9, Qhat(7/2, 9))
            (7.9000000000000004?, 7/2 mod 9)

        ::

            sage: K.<a> = NumberField(x^3+x+1)
            sage: Ak = Adeles(K)
            sage: Khat = ProfiniteNumbers(K)
            sage: Adele(Ak, [-1, 1+I], Khat(a/3, 100/3))
            (-1, 1 + 1*I, 1/3*a mod (100/3))

        TESTS::

            sage: Adele(A, [3.0, -1.0], 7)
            Traceback (most recent call last):
            ...
            TypeError: infinite must have length 1
            sage: Adele(Ak, 1.0, 7)
            Traceback (most recent call last):
            ...
            TypeError: infinite must be a list
            sage: Adele(A, [I], 7)
            Traceback (most recent call last):
            ...
            TypeError: 0th infinite value (I) must lie in Real Interval Field with 53 bits of precision
            sage: Adele(A, [1.0], a+1)
            Traceback (most recent call last):
            ...
            TypeError: finite must lie in Profinite Numbers of Rational Field
        """
        CommutativeAlgebraElement.__init__(self, parent)

        K = parent.base()
        K_oo = infinite_completions(K, fields_only=True)

        if len(K_oo) == 1 and (infinite in K_oo[0] or
                                (K_oo[0] is RIF and infinite in RR) or
                                (K_oo[0] is CIF and infinite in CC)):
            self._infinite = [infinite]
        else:
            try:
                self._infinite = list(infinite)
            except TypeError:
                raise TypeError("infinite must be a list")
        
        if len(self._infinite) != len(K_oo):
            raise ValueError("infinite must have length {}".format(len(K_oo)))

        for i in range(len(K_oo)):
            val = self._infinite[i]
            if not (val in K_oo[i] or (K_oo[i] is RIF and val in RR) or
                    (K_oo[i] is CIF and val in CC)):
                raise TypeError("{}th infinite value ({}) must lie in {}".format(i, val, K_oo[i]))
            self._infinite[i] = K_oo[i](val)

        Khat = ProfiniteNumbers(K)
        if finite not in Khat:
            raise TypeError("finite must lie in {}".format(Khat))
        self._finite = Khat(finite)

    def __getitem__(self, p):
        r"""
        Return the projection of this adèle to the field of ``p``-adic numbers

        INPUT:

        - ``p`` -- a prime number or ``Infinity``

        Only implemented for `\QQ`-adèles, as no general implementation of
        completions at finite places of a number field exists in SageMath at the
        time of writing.
        
        View `\Bold{A}_\QQ` as `\RR \times \prod_p' \QQ_p` with `p` ranging
        over all prime numbers and the restructed product taken with respect to
        the open subrings `\ZZ_p`. This method implements the projections
        `\Bold{A}_\QQ \to \RR` and `\Bold{A}_\QQ \to \QQ_p` for `p` a prime
        number.

        EXAMPLES::

            sage: A = Adeles(QQ)
            sage: a = A(1.23456789, Qhat(1/3, 2^5 * 3^10)); a
            (1.2345678899999999?, 1/3 mod 1889568)
            sage: a[oo]
            1.2345678899999999?
            sage: a[2]
            1 + 2 + 2^3 + O(2^5)
            sage: a[3]
            3^-1 + O(3^10)
            sage: a[5]
            O(5^0)

        REFERENCES:

        Section 4.6 of [Her2021].
        """
        if self.parent().base() is not QQ:
            raise NotImplementedError("projection to `p`-adics only implemented over rationals")
        if p not in Primes() and p is not Infinity:
            raise ValueError("p should be a prime number or Infinity")
        if p is Infinity:
            return self.infinite_part(0)
        return self.finite_part()[p]

    def _repr_(self):
        """
        Return a string representation of this adèle

        EXAMPLES::

            sage: K.<zeta5> = CyclotomicField(5)
            sage: A = Adeles(K)
            sage: Khat = ProfiniteNumbers(K)
            sage: A([-1, I], Khat(zeta5/2, 100))
            (-1, 1*I, 1/2*zeta5 mod (100))
            sage: inf = CIF(RIF(-oo, oo), RIF(-oo, oo))
            sage: A([-97*I, inf], zeta5/3)
            (-97*I, CC, 1/3*zeta5)
        """
        R = RIF(-oo, oo)
        C = CIF(R, R)
        rep = "("
        for i in range(len(self.infinite_part())):
            x_oo = self.infinite_part(i)
            if x_oo.endpoints() == R.endpoints():
                rep += "RR, "
            elif x_oo.endpoints() == C.endpoints():
                rep += "CC, "
            else:
                rep += repr(x_oo) + ", "
        rep += repr(self.finite_part()) + ")"
        return rep

    def _add_(self, other):
        """
        Return the sum of this adèle and ``other``

        EXAMPLES::

            sage: A = Adeles(QQ)
            sage: a = A(1.5, Qhat(-1/6, 2))
            sage: b = A(2.5, Qhat(3/2, 12))
            sage: a + b
            (4, 4/3 mod 2)
            sage: a + 1
            (2.5000000000000000?, 5/6 mod 2)
        
        ::

            sage: K.<zeta5> = CyclotomicField(5)
            sage: Ak = Adeles(K)
            sage: Khat = ProfiniteNumbers(K)
            sage: c = Ak([I, -I], Khat((1+zeta5+zeta5^2)/2, 100))
            sage: d = Ak([3.5, I], Khat((zeta5^3+zeta5^4)/2, 200))
            sage: c + d
            (3.5000000000000000? + 1*I, 0, 0 mod (100))

        REFERENCES:

        Section Arithmetic in Section 3.4 of [Her2021].
        """
        t = len(self.infinite_part())
        infinite = [self.infinite_part(i) + other.infinite_part(i) for i in range(t)]
        finite = self.finite_part() + other.finite_part()
        return self.__class__(self.parent(), infinite, finite)

    def _sub_(self, other):
        """
        Return the difference of this adèle and ``other``

        EXAMPLES::

            sage: A = Adeles(QQ)
            sage: a = A(-10.375, Qhat(4/3, 5))
            sage: b = A(5, Qhat(2/5, 5,))
            sage: a - b
            (-15.375000000000000?, 14/15 mod 5)
            sage: b - a
            (15.375000000000000?, 61/15 mod 5)

        ::

            sage: K.<a> = NumberField(x^2+3)
            sage: Ak = Adeles(K)
            sage: Khat = ProfiniteNumbers(K)
            sage: b = Ak(I, Khat(a/4, 10*a))
            sage: c = Ak(1, Khat(1/4, 30))
            sage: b - c
            (-1 + 1*I, 1/4*a - 1/4 mod (-10*a))
            sage: c - c
            (0, 0 mod (30))
            sage: b - a
            (-0.73205080756887720?*I, -3/4*a mod (-10*a))

        REFERENCES:

        Section Arithmetic in Section 3.4 of [Her2021].
        """
        t = len(self.infinite_part())
        infinite = [self.infinite_part(i) - other.infinite_part(i) for i in range(t)]
        finite = self.finite_part() - other.finite_part()
        return self.__class__(self.parent(), infinite, finite)

    def _mul_(self, other):
        """
        Return the product of this adèle and ``other``

        EXAMPLES::

            sage: A = Adeles(QQ)
            sage: a = A(-1, Qhat(1/5, 80/3))
            sage: b = A(79, Qhat(1/2, 80))
            sage: a * b
            (-79, 1/10 mod 8/3)

        ::

            sage: K.<a> = NumberField(x^2+x+1)
            sage: Ak = Adeles(K)
            sage: Khat = ProfiniteNumbers(K)
            sage: b = Ak(I, Khat(a, 10*a))
            sage: c = Ak([CIF(2.3+I)], Khat(7*a+2, 30*a-3, a))
            sage: b * b
            (-1, -a - 1 mod (10))
            sage: a * b
            (-0.86602540378443860? - 0.50000000000000000?*I, -a - 1 mod (-10*a - 10))

        REFERENCES:

        Section Arithmetic in Section 3.4 of [Her2021].
        """
        t = len(self.infinite_part())
        infinite = [self.infinite_part(i) * other.infinite_part(i) for i in range(t)]
        finite = self.finite_part() * other.finite_part()
        return self.__class__(self.parent(), infinite, finite)

    def _div_(self, other):
        """
        Return the quotient of this adèle by ``other``

        EXAMPLES::

            sage: A = Adeles(QQ)
            sage: a = A([3.0], Qhat(6, 14))
            sage: b = A([2.0], 3/2)
            sage: a / b
            (1.5000000000000000?, 4 mod 28/3)

        ::

            sage: K.<a> = NumberField(x^4-5)
            sage: Ak = Adeles(K)
            sage: Khat = ProfiniteNumbers(K)
            sage: b = Ak([5, 5, 5], Khat(5, 1024/9))
            sage: c = Ak([5, -1, I], a)
            sage: b / c
            (1, -5, -5*I, a^3 mod (1024/45*a^3))


        .. NOTE::

            One can only divide by adèles whose finite part has zero modulus and
            non-zero value. If ``other`` does not satisfy this, an exception
            is raised::
        
                sage: c / b
                Traceback (most recent call last):
                ...
                ValueError: division by profinite number with non-zero modulus
                sage: z = Ak([1, 1, 1], 0)
                sage: b / z
                Traceback (most recent call last):
                ...
                ZeroDivisionError: profinite number division by zero

        REFERENCES:

        Section Arithmetic in Section 3.4 of [Her2021].
        """
        t = len(self.infinite_part())
        infinite = [self.infinite_part(i) / other.infinite_part(i) for i in range(t)]
        finite = self.finite_part() / other.finite_part()
        return self.__class__(self.parent(), infinite, finite)

    def _richcmp_(self, other, op):
        r"""
        Compare this adèle with ``other`` based on the relation ``op``

        We only implement equality and non-equality.

        We declare two adèles equal if the *could* be equal, i.e. if their
        represented subsets have non-empty intersection.

        Inequality is defined as not being equal.

        EXAMPLES::

            sage: A = Adeles()
            sage: Qhat = ProfiniteNumbers(QQ)
            sage: b = A([RIF(2.0, 3.0)], Qhat(3/7, 10/7))
            sage: c = A([RIF(2.5, 3.5)], Qhat(13/7, 20/7))
            sage: d = A([2.1], Qhat(13/7, 20/7))
            sage: e = A([2.1], Qhat(3/7, 20/7))
            sage: b == c
            True
            sage: b == d
            True
            sage: c == d
            False
            sage: b != e
            False
            sage: d == e
            False
            sage: c != d
            True

        ::

            sage: K.<i> = NumberField(x^2+1)
            sage: Ak = Adeles(K)
            sage: Khat = ProfiniteNumbers(K)
            sage: b = Ak([I], Khat(i/3, (10+i)/3))
            sage: c = Ak([RIF(-1, 4)*I], Khat(-10/3, 2/3*(10+i)))
            sage: b == c
            True
            sage: b != c
            False

        REFERENCES:

        Section 5.4 of [Her2021].

        TESTS::
            
            sage: b < c
            Traceback (most recent call last):
            ...
            NotImplementedError: only equality and inequality are implemented
        """
        from sage.structure.richcmp import op_EQ, op_NE
        if op == op_EQ:
            for i in range(len(self.infinite_part())):
                try:
                    self.infinite_part(i).intersection(other.infinite_part(i))
                except ValueError:
                    # This indicates the intersection is empty
                    return False
            return self.finite_part() == other.finite_part()
        if op == op_NE:
            return not (self == other)
        raise NotImplementedError("only equality and inequality are implemented")

    def infinite_part(self, index=None):
        """
        Return the infinite part of this adèle as a list, or a single entry

        INPUT:

        - ``index`` -- non-negative integer smaller than the length of our
          infinite part (optional); if specified, return the ``index``-th entry
          of our infinite part

        OUTPUT:
        
        Return the infinite part of this adèle, or the ``index``-th entry if
        ``index`` is specified.

        EXAMPLES::

            sage: K.<a> = NumberField(x^5 + 10)
            sage: A = Adeles(K)
            sage: a = A([1.6, I, -I], 0)
            sage: a.infinite_part()
            [1.6000000000000001?, 1*I, -1*I]
            sage: a.infinite_part(0)
            1.6000000000000001?
            sage: a.infinite_part(2)
            -1*I
        """
        if index is None:
            return self._infinite
        return self._infinite[index]

    def finite_part(self):
        """
        Return the finite part of this adèle
        
        EXAMPLES::

            sage: A = Adeles(QQ)
            sage: a = A(2.0, Qhat(17/2, 1000/3))
            sage: a.finite_part()
            17/2 mod 1000/3
        """
        return self._finite

    def to_rational_vector(self):
        r"""
        Convert this adèle to a vector of `\QQ`-adèles
    
        Let `K` be our base number field, `\alpha` its generator over `\QQ` and
        `n` its degree over `\QQ`. Then every `x \in \Bold{A}_K` can be written
        uniquely as `x = \sum_{i=0}^{n-1} x_i \alpha^i` with
        `x_i \in \Bold{A}_\QQ`. This induces a map
        `\phi: \Bold{A}_K \to \Bold{A}_\QQ^n`.

        This method implements `\phi`.
        
        OUTPUT:

        A vector `(x_0, ..., x_{n-1})` of `\QQ`-adèles such that the following
        holds. Let `i \in \{0, ..., n-1\}` and let
        `\phi_i: \Bold{A}_K \to \Bold{A}_\QQ` be the composition of `\phi`
        with the projection to the `i`-th `\Bold{A}_\QQ`. Then for any
        `\alpha` that ``self`` represents, `\phi_i(\alpha)` is represented by
        `x_i`.

        EXAMPLES::

            sage: K.<a> = NumberField(x^3-2)
            sage: AK = Adeles(K)
            sage: b = AK([-7, 2+I], 1+2*a+3*a^2)
            sage: c = b.to_rational_vector(); c
            ((-1.00000000000000?, 1), (-1.92285836561943?, 2), (-2.25358945349955?, 3))

        Let us check that these infinite parts are correct::

            sage: x = [ci[oo] for ci in c]; x
            [-1.00000000000000?, -1.92285836561943?, -2.25358945349955?]
            sage: emb = infinite_completions(K, embeddings_only=True)
            sage: x[0] + x[1]*emb[0](a) + x[2]*emb[0](a^2)
            -7.0000000000000?
            sage: x[0] + x[1]*emb[1](a) + x[2]*emb[1](a^2)
            2.0000000000000? + 1.00000000000000?*I

        .. SEEALSO::

            :meth:`~adeles.profinite_number.ProfiniteNumber.to_rational_vector`

        REFERENCES:

        Section 4.4 of [Her2021].
        """
        from sage.modules.free_module_element import vector
        from sage.matrix.constructor import matrix
        K = self.parent().base()
        n = K.absolute_degree()
        r, s = K.signature()
        emb = infinite_completions(K, embeddings_only=True)

        # We compute the infinite parts using linear algebra over RIF.
        A = []
        for i in range(r): # the real primes
            A.append([emb[i](K.gen()**j) for j in range(n)])
        for i in range(r, r+s): # the complex primes
                A.append([emb[i](K.gen()**j).real() for j in range(n)])
                A.append([emb[i](K.gen()**j).imag() for j in range(n)])
        A = matrix(RIF, A)

        Y = [self.infinite_part(i) for i in range(r)]
        for i in range(r, r+s):
                Y.append(self.infinite_part(i).real())
                Y.append(self.infinite_part(i).imag())
        Y = vector(Y)

        infinites = A.solve_right(Y)
        
        finites = self.finite_part().to_rational_vector()

        A_Q = Adeles(QQ)
        return vector([A_Q([infinites[i]], finites[i]) for i in range(n)])


class Adeles(UniqueRepresentation, CommutativeAlgebra):
    """
    Adèle Ring of a Number Field

    REFERENCES:

    Section 3.4 of [Her2021].

    .. automethod:: _element_constructor_
    """

    Element = Adele

    def __classcall__(cls, K=QQ):
        """
        Construct the adèle ring of the number field `K`

        INPUT:

        - ``K`` -- a number field (default: ``QQ``)

        EXAMPLES::

            sage: Adeles(QQ)
            Adèle Ring of Rational Field

        This method ensures that the following returns ``True``::

            sage: Adeles() is Adeles(QQ)
            True

        TESTS::

            sage: Adeles("not a number field")
            Traceback (most recent call last):
            ...
            TypeError: K should be a number field
        """
        from sage.rings.number_field.number_field import is_NumberField
        if not is_NumberField(K):
                raise TypeError("K should be a number field")
        return super(Adeles, cls).__classcall__(cls, K)

    def __init__(self, K):
        r"""
        Construct the adèle ring of the number field ``K``

        INPUT:

        - ``K`` -- a number field (default: `\QQ`)

        EXAMPLES::

            sage: Adeles()
            Adèle Ring of Rational Field
            sage: K.<a> = NumberField(x^5-3*x+1)
            sage: Adeles(K)
            Adèle Ring of Number Field in a with defining polynomial x^5 - 3*x + 1
        """
        # Input verification is done by __classcall__().
        CommutativeAlgebra.__init__(self, K)

    def _repr_(self):
        """
        Return a string representation of this adèle ring

        EXAMPLES::

            sage: K.<a> = NumberField(x^3+x+1)
            sage: Adeles(K)
            Adèle Ring of Number Field in a with defining polynomial x^3 + x + 1
        """
        return "Adèle Ring of {}".format(self.base())

    def _latex_(self):
        r"""
        Return latex-formatted string representation of this adèle ring

        EXAMPLES::

            sage: K.<a> = NumberField(x^2+14)
            sage: latex(Adeles(K))
             \Bold{A}_{ \Bold{Q}[a]/(a^{2} + 14) }
        """
        from sage.misc.latex import latex
        return r" \Bold{A}_{" + latex(self.base()) + "} "

    def _element_constructor_(self, x, y=None):
        r"""
        Construct an adèle

        INPUT:

        We accept many input formats. Denote our base number field by `K` and
        its signature by `(r,s)`.

        The standard format is a pair `(x,y)` where `x` specifies the infinite
        part and `y` specifies the finite part. Here `x` should be a list of
        length `r+s` with the first `r` entries in ``RIF`` and the last `s`
        entries in ``CIF``. And `y` should be a profinite `K`-number.

        The other formats accept only one argument and they can be one of the
        following.

        - a `K`-adèle; construct a copy
        - an element `x` of `K`; construct the (diagonal) image of `x` in this
          adèle ring
        - a profinite `K`-integer; specifies the finite part only
        - a `K`-idèle; convert the idèle to an adèle (see :meth:`_from_idele`)

        If `K` is `\QQ`, we also accept a list consisting of `p`-adic numbers,
        for distinct prime numbers `p`, as well as at most one real number.
        See :meth:`_from_padics` for details.

        EXAMPLES:

        We start with the standard format::

            sage: K.<a> = NumberField(x^3-7)
            sage: Ak = Adeles(K)
            sage: Khat = ProfiniteNumbers(K)
            sage: b = Ak([3.14, -I], Khat(a+1/5, 9*a^2)); b
            (3.1400000000000002?, -1*I, (a mod (9*a^2))/(a + 1))

        Let's make a copy of ``b``::

            sage: c = Ak(b); c
            (3.1400000000000002?, -1*I, (a mod (9*a^2))/(a + 1))
        
        We create the adèle corresponding to `a/2`::

            sage: Ak(a/2)
            (0.9564655913861945?, -0.47823279569309730? + 0.82832349998615107?*I, 1/2*a)

        Upon given a profinite ``K``-number, the values at the infinite primes
        are completely unknonwn::

            sage: Ak(Khat(1/10, 100*a^2))
            (RR, CC, 1/10 mod (100*a^2))

        We can also convert an idèle to an adèle::

            sage: J = Ideles(K)
            sage: u = J([-1, I], {a: (a, 6)}); u
            Idele with values:
              infinity_0:   -1
              infinity_1:   1*I
              (7, a):       a * U(6)
              other primes: 1 * U(0)
            sage: Ak(u)
            (-1, 1*I, a mod (686, 49*a + 343, 49*a^2 + 343))

        Lastly we demonstrate the construction of a `\QQ`-adèle using `p`-adic
        numbers::

            sage: A = Adeles(QQ)
            sage: a_2 = Qp(2)(5/2, 2); a_2
            2^-1 + 2 + O(2^2)
            sage: a_3 = Qp(3)(7/27, -1); a_3
            3^-3 + 2*3^-2 + O(3^-1)
            sage: a = A([-7.25, a_2, a_3]); a
            (-7.2500000000000000?, 23/54 mod 4/3)
            sage: a[2]
            2^-1 + 2 + O(2^2)
            sage: a[3]
            3^-3 + 2*3^-2 + O(3^-1)

        .. automethod:: _from_padics
        .. automethod:: _from_idele
        """
        K = self.base()

        if y is None:
            # Is x already a K-adèle?
            if isinstance(x, Adele) and x.parent() is self:
                return self.element_class(self, x.infinite_part(), x.finite_part())

            # Does x lie in the base field?
            if x in K:  # coercion K --> A_K
                infinite = [phi(x) for phi in infinite_completions(K, embeddings_only=True)]
                return self.element_class(self, infinite, x)

            # Is x a profinite K-number? (Or profinite K-integer, or ...)
            Khat = ProfiniteNumbers(K)
            if hasattr(x, "parent") and Khat.has_coerce_map_from(x.parent()):
                R = RIF(-oo, oo)
                C = CIF(R, R)
                r, s = K.signature()
                infinite = [R for i in range(r)] + [C for i in range(s)]
                return self.element_class(self, infinite, Khat(x))

            # Is x a K-idèle?
            if isinstance(x, Idele) and x.parent().number_field() is K:
                return self._from_idele(x)

            # Is K==QQ and x a list of `p`-adics?
            if K is QQ:
                from sage.rings.padics.generic_nodes import is_pAdicRing, is_pAdicField
                def is_pAdic(a):
                    """Utility function to check if ``a`` is real or a p-adic number"""
                    if a in RIF: return True
                    if not hasattr(a, "parent"): return False
                    return is_pAdicRing(a.parent()) or is_pAdicField(a.parent())
                if isinstance(x, list) and all([is_pAdic(a) for a in x]):
                    return self._from_padics(x)

        return self.element_class(self, x, y)

    def _from_idele(self, idele):
        r"""
        Construct the adèle corresponding to the idèle ``idele``

        This implements the inclusion of the idèles into the adèles. Due to the
        different ways of storing adèles and idèles, this may lose precision:
        the represented subset of the returned ``Adele`` will contain the
        represented subset of ``idèle`` and it might be bigger.

        EXAMPLES::

            sage: A = Adeles(QQ)
            sage: from idele import Ideles
            sage: J = Ideles(QQ)
            sage: u = J(6, {2: (1, 1), 3: (1/3, 0)})
            sage: A(u)
            (6, 1/3 mod 2/3)
            sage: v = J(7.9, {3: (2, 2), 5: (1, 1)})
            sage: A(v)
            (7.9000000000000004?, 11 mod 90)

        Note the factor `2` in te modulus of the finite part in this last
        example. This is because ``v[2]`` is ``1 * U(0)``, which has represented
        subset `\ZZ_2^*`, which equals `1 + 2\ZZ_2`. Hence we know that the
        finite part of ``A(v)`` is ``1`` moduluo ``2``, even though no explicit
        value is stored for ``v`` at ``2``.

        A similar thing happens in the following example over a non-trivial
        number field::

            sage: K.<a> = NumberField(x^2+5)
            sage: Ak = Adeles(K)
            sage: Jk = Ideles(K)
            sage: u = Jk([I], {})
            sage: Ak(u)
            (1*I, a mod (2, a + 1))

        Now a more complicated example::

            sage: p2, p3 = K.prime_above(2), K.prime_above(3)
            sage: v = Jk([1+I], {p2: (a, 3), p3: (1/3-a, 3)})
            sage: Ak(v)
            (1 + 1*I, 1/3*a + 2/3 mod (36, 2*a + 14))

        This conversion defines a coercion::

            sage: a = A([2.5], Qhat(1/5, 10))
            sage: u = J([-0.5], {2: (1/2, 2), 5: (1, 1)})
            sage: a + u
            (2, 87/10 mod 10)
            sage: u - a
            (-3, 83/10 mod 10)
            sage: a * u
            (-1.2500000000000000?, 7/10 mod 1)

        REFERENCES:

        Section 4.3 of [Her2021].
        """        
        infinite = idele.infinite_part().copy()

        if idele.has_exact_finite_part():
            return self.element_class(self, infinite, idele.finite_part())

        from sage.arith.misc import CRT
        from sage.misc.misc_c import prod
        K = self.base()
        Ohat = ProfiniteIntegers(K)
        Khat = ProfiniteNumbers(K)

        if K is QQ:
            norm_2_primes = [ZZ(2)]
        else:
            norm_2_primes = [P for P in K.primes_above(2) if P.norm() == 2]

        integral, denominator = idele.very_integral_split()
        values = []
        moduli = []
        for P in set(integral.stored_primes() + norm_2_primes):
            if (K is QQ and P == 2) or (K is not QQ and P.norm() == 2):
                n_P = max(1, integral[P].prec())
            else:
                n_P = integral[P].prec()
            e_P = n_P + integral[P].valuation()
            if e_P >= 1:
                values.append(integral[P].center())
                moduli.append(P**e_P)
        if K is QQ:
            value = CRT(values, moduli)
        else:
            value = K.solve_CRT(values, moduli)
        modulus = prod(moduli)
        finite = Khat(Ohat(value, modulus), denominator)

        return self.element_class(self, infinite, finite)

    def _from_padics(self, padics):
        r"""
        Construct an adèle over `\QQ` from the list of `p`-adic numbers
        ``padics``
        
        Only implemented over `\QQ`, as no general implementation of `p`-adic
        numbers currently exists for general number fields.

        INPUT:

        - ``padics`` -- a list consisting of `p`-adic numbers, for distinct
          prime numbers `p`, as well as at most one real number

        OUTPUT:

        The `\QQ`-adèle with infinite part equal to the real number in the list,
        if it exists, or `\RR` otherwise, and with finite part given by
        :meth:`~adeles.profinite_number.ProfiniteNumbers._from_padic_numbers`,
        to which we give as input ``padics`` with the optional real number
        removed.

        EXAMPLES::

            sage: A = Adeles()
            sage: a_2 = Qp(2)(6, 3); a_2
            2 + 2^2 + O(2^3)
            sage: a_5 = Qp(5)(2/5, 1); a_5
            2*5^-1 + O(5)
            sage: a = A._from_padics([9.7, a_2, a_5]); a
            (9.6999999999999993?, 102/5 mod 40)
            sage: a[2]
            2 + 2^2 + O(2^3)
            sage: a[3]
            O(3^0)
            sage: a[5]
            2*5^-1 + O(5)
            sage: a[oo]
            9.6999999999999993?

        ::

            sage: b_3 = Qp(3)(0, 2)
            sage: b_7 = Qp(7)(1/(2*49), -1)
            sage: b = A._from_padics([b_7, b_3]); b
            (RR, 18/49 mod 9/7)
            sage: b[3] == b_3 and b[7] == b_7
            True

        REFERENCES:

        Section 4.6 of [Her2021].
        """
        reals = [x for x in padics if x in RIF]
        if len(reals) == 0:
            infinite = RIF(-oo, oo)
        elif len(reals) == 1:
            infinite = reals[0]
            padics.remove(infinite)
        else:
            raise ValueError("can't specify multiple real numbers for one QQ-adèle")

        Qhat = ProfiniteNumbers(QQ)
        return self.element_class(self, infinite, Qhat(padics))

    def _coerce_map_from_(self, domain):
        r"""
        Return whether or not ``domain`` coerces into this adèle ring

        The following structures coerce into this adèle ring:

        - our base field;
        - the idèle group of our base field.

        EXAMPLES::

            sage: K.<a> = NumberField(x^9+x+1)
            sage: A = Adeles(K)
            sage: A._coerce_map_from_(K)
            True
            sage: A._coerce_map_from_(CyclotomicField())
            False
            sage: from idele import Ideles
            sage: J = Ideles(K)
            sage: A._coerce_map_from_(J)
            True

        EXAMPLES::

            sage: A._coerce_map_from_(ZZ)
            True
        """
        from .idele import Ideles
        K = self.base()
        if K.has_coerce_map_from(domain):
            return True
        J = Ideles(K)
        if J.has_coerce_map_from(domain):
            return True
        return False

    def _an_element_(self):
        """
        Return a typical element of this adèle ring

        EXAMPLES::

            sage: Adeles().an_element()
            (1, 2/5 mod 6/5)
            sage: K.<a> = NumberField(x^3-5)
            sage: Adeles(K).an_element()
            (1, 1*I, 8/5*a^2 mod (7/5*a^2 - 1/5))
        """
        r, s = self.number_field().signature()
        infinite = [RIF.an_element() for i in range(r)] + [CIF.an_element() for i in range(s)]
        finite = ProfiniteNumbers(self.number_field()).an_element()
        return self.element_class(self, infinite, finite)

    def some_elements(self):
        """
        Return some elements of this adèle ring
        
        EXAMPLES::

            sage: Adeles().some_elements()
            [(0, 0), (1, 2/5 mod 6/5), (1, 1), (4.571428571428572?, 17/7 mod 30/7)]
        """
        return [self.zero(), self.an_element(), self.one(), 25*self.an_element()/7+1]

    def random_element(self):
        """
        Return a random element of this adèle ring

        EXAMPLES::

            sage: [Adeles().random_element() for i in range(8)] # random
            [(0.27373183534599522?, 8 mod 9),
             (-0.093881488288479976?, 0 mod 7),
             (0.30161163018038062?, 2 mod 20),
             (0.41150508905962280?, -5),
             (-0.65571439239360441?, 1),
             (-0.73036548915661804?, 1/5 mod 13/5),
             (0.22238770477164250?, 1 mod 45/2),
             (-0.95472024452579408?, 5/3 mod 2)]

        ::

            sage: [Adeles(K).random_element() for i in range(8)] # random
            [(0.79423215622331634?, -0.40137427709553509? - 0.64534892614076900?*I, 43/16*a^2 + 1/16*a - 1/16 mod (129/8*a^2 + 141/4*a + 21/4)),
             (0.52942291646206008?, -0.58341619510920518? + 0.36230656269735762?*I, 1/3*a^2 mod (2/3)),
             (0.89152090833818054?, 0.49795817189108283? - 0.70150555814011307?*I, 9*a - 2 mod (42)),
             (0.44924372673739877?, 0.26028465739297824? - 0.040401847180406625?*I, 0 mod (1/2)),
             (0.073877767325941424?, -0.91366841344236605? - 0.021723717207447813?*I, -6*a^2 + a mod (26*a + 13)),
             (-0.33577218142520793?, 0.29090471478072467? + 0.43029026051764663?*I, a^2 + 1/2*a + 1 mod (26)),
             (0.49505274874739480?, 0.24198576476487932? + 0.25729961424886950?*I, 1/4*a + 5/4 mod (5/4*a^2)),
             (-0.15573868218812215?, 0.12998234921383456? + 0.99415852426545226?*I, -2*a^2 mod (-a^2 - 1))]
        """
        r, s = self.number_field().signature()
        infinite = [RIF.random_element() for i in range(r)] + [CIF.random_element() for i in range(s)]
        finite = ProfiniteNumbers(self.number_field()).random_element()
        return self.element_class(self, infinite, finite)

    def gens(self):
        """
        Return a tuple of generators of this ring, which is ``(1,)``

        EXAMPLES::

            sage: Adeles().gens()
            ((1, 1),)
        """
        return (self(1), )

    def gen(self, n=0):
        """
        Return the ``n``-th generator of this ring

        As this ring has only one generator, we only accept ``n == 0``.

        INPUT:

        - ``n`` -- the index of the generator to return (default: ``0``); must
          be zero

        EXAMPLES::

            sage: Adeles(CyclotomicField(5)).gen()
            (1, 1, 1)
            sage: Adeles().gen(0)
            (1, 1)

        TESTS::

            sage: Adeles(QQ).gen(1)
            Traceback (most recent call last):
            ...
            IndexError: n must be 0
        """
        if n == 0:
            return self(1)
        else:
            raise IndexError("n must be 0")

    def ngens(self):
        """
        Return the number of generators of this ring, which is `1`

        EXAMPLES::

            sage: Adeles().ngens()
            1
        """
        return ZZ(1)

    def is_finite(self):
        """
        Return ``False``, indicating that this adèle ring is not finite

        EXAMPLES::

            sage: Adeles().is_finite()
            False
        """
        return False

    def is_exact(self):
        """
        Return ``False``, indicating that doing arithmetic can lead to precision
        loss

        EXAMPLES::

            sage: Adeles().is_exact()
            False
        """
        return False

    def is_integral_domain(self, proof=None):
        """
        Return ``False``, indicating that this adèle ring is not an integral
        domain

        EXAMPLES::

            sage: Adeles().is_integral_domain()
            False
        """
        return False

    def is_field(self, proof=True):
        """
        Return ``False``, indicating that this ring is not a field

        EXAMPLES::

            sage: Adeles().is_field()
            False
        """
        return False

    def characteristic(self):
        """
        Return the characteristic of this ring, which is zero

        EXAMPLES::

            sage: Adeles().characteristic()
            0
        """
        return ZZ(0)

    def order(self):
        """
        Return ``Infinity``, indicating that this ring has infinitely many
        elements

        EXAMPLES::

            sage: Adeles().order()
            +Infinity
        """
        return Infinity

    def epsilon(self):
        """
        Return the precision error of elements in this ring

        As this depends on the elements, we can give no reasonable answer and
        hence raise a ``NotImplementedError``.

        EXAMPLES::

            sage: Adeles().epsilon()
            Traceback (most recent call last):
            ...
            NotImplementedError: precision error depends on the elements involved
        """
        raise NotImplementedError("precision error depends on the elements involved")

    def construction(self):
        """
        Return a pair ``(functor, parent)`` such that ``functor(parent)``
        returns this adèle ring.

        EXAMPLES::

            sage: A, Q = Adeles().construction(); A, Q
            (AdelizationFunctor, Rational Field)
            sage: A(Q) is Adeles()
            True

        ::

            sage: K.<a> = NumberField(x^5-2)
            sage: A, K = Adeles(K).construction(); A, K
            (AdelizationFunctor, Number Field in a with defining polynomial x^5 - 2)
            sage: A(K) is Adeles(K)
            True
        """
        return AdelizationFunctor(), self.base()

    def number_field(self):
        """
        Return the base number field of this adèle ring

        EXAMPLES::

            sage: K.<a> = NumberField(x^5+7*x+9)
            sage: Adeles(K).number_field()
            Number Field in a with defining polynomial x^5 + 7*x + 9
        """
        return self.base()


class AdelizationFunctor(ConstructionFunctor):
    """
    The functor sending a number field to its adèle ring
    """
    rank = 7

    def __init__(self, args=None, kwds=None):
        """
        Create an AdelizationFunctor

        EXAMPLES::

            sage: AdelizationFunctor()
            AdelizationFunctor
        """
        self.args = args or ()
        self.kwds = kwds or {}
        ConstructionFunctor.__init__(self, NumberFields(), Rings())

    def _apply_functor(self, K):
        """
        Apply this functor to the number field ``K``

        OUPUT:
        The adèle ring of the number field ``K``

        EXAMPLES::

            sage: A = AdelizationFunctor()
            sage: A(QQ)
            Adèle Ring of Rational Field
            sage: K.<a> = NumberField(x^3+7)
            sage: A(K)
            Adèle Ring of Number Field in a with defining polynomial x^3 + 7
        """
        return Adeles(K, *self.args, **self.kwds)



