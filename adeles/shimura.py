r"""
Shimura's Connecting Homomorphism

Let `K` be an imaginary quadratic number field, let `\theta` be a generator of
its ring of integers. View the ring `\hat{K}` of profinite `K`-numbers as a
`\hat{\QQ}`-vector space with basis `(\theta, 1)`. Then *Shimura's connecting
homomorphism* is the map `g_\theta: \hat{K}^* \to GL_2(\hat{\QQ})` that sends
`x \in \hat{K}^*` to the transpose of the matrix that represents the
`\hat{\QQ}`-linear map `\hat{K} \to \hat{K}` given by multiplication by `x`.

This file implements Shimura's connecting homomorphism in the function
:func:`shimura_connecting_homomorphism`.

Moreover the function :func:`factored_shimura_connecting_homomorphism`
evaluations Shimura's connecting homomorphism and factors the resulting
`GL_2(\hat{\QQ})`-matrix into a product of a matrix `B \in GL_2(\hat{\ZZ})` and
a matrix `A \in GL_2^+(\QQ)`, using :func:`~adeles.matrix.factor_GLQhat`.

REFERENCES:

[Her2021] Mathé Hertogh, Computing with adèles and idèles, master's thesis,
Leiden University, 2021.

For context on the utility of these function, see Chapter 9 of [Her2021].
This file is in particular based on Sections 9.3.2 and 9.3.3 of [Her2021].

AUTHORS:

- Mathé Hertogh (2021-07): initial version based on [Her2021]
"""

# ****************************************************************************
#       Copyright (C) 2021 Mathé Hertogh <m.c.hertogh@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.rings.integer_ring import ZZ
from sage.rings.rational_field import QQ
from sage.arith.functions import lcm
from sage.misc.misc_c import prod
from sage.matrix.constructor import matrix

from .profinite_number import Qhat
from .adele import Adeles
from .idele import Ideles
from .matrix import modulus, denominator, factor_GLQhat


def shimura_connecting_homomorphism(u, output_prec=None):
    r"""
    Evaluate Shimura's connecting homomorphism at the idele ``u``

    INPUT:

    - ``u`` -- a `K`-idèle for some imaginary quadratic number field `K` whose
      ring of integers is generated by ``K.gen()``; the point to evaluate the
      homomorphism in
    - ``output_prec`` -- a positive integer; the desired output precision

    OUTPUT:

    A pair `(v, M)` where `v` is a `K`-idèle whose represented subset is
    contained in that of `u` and `M` is a pair `M = (E, \Delta)` with `M` a
    `2 \times 2`-matrix over the ring of profinite `\QQ`-numbers with integral
    precision (i.e. modulus) divisible by ``output_prec`` and `\Delta` a
    positive rational number such that every `x \in \hat{K}^*` that `v`
    represents satisfies `g(x)\hat{\ZZ} = \Delta\hat{\ZZ}` and `E` represents
    `g(x)`. Here `g: \hat{K}^* \to GL_2(\hat{\QQ})` denotes Shimura's connecting
    homomorphism with respect to the basis ``(K.gen(), 1)``.

    If ``output_prec`` is not specified, then `v` equals `u` and no guarantees
    are made about the precision of `E`. In this case we only return `M` (not
    `v`).

    ALGORITHM:

    We perform Algorithm 9.1 of [Her2021].

    EXAMPLES:

    First we create an appropriate number field and check that its generator
    generates the ring of integers. ::

        sage: K.<a> = NumberField(x^2 - x + 2)
        sage: K.integral_basis()
        [1, a]
        sage: J = Ideles(K)

    Let's try to evaluate Shimura's connecting homomorphism without specifying
    an output precision. ::

        sage: u = J(1, {a: (a, 3), 3: (-1, 1), 5: (1/5, 0)}); u
        Idèle with values:
          infinity_0:   1
          (2, a):       a * U(3)
          (3):          -1 * U(1)
          (5):          1/5 * U(0)
          other primes: 1 * U(0)
        sage: shimura_connecting_homomorphism(u)
        (
        [ 1/5 mod 6/5 6/5 mod 12/5]
        [ 3/5 mod 6/5  4/5 mod 6/5], 2/25
        )

    And now let's get an output precision of at least `12`::

        sage: v, M = shimura_connecting_homomorphism(u, 12)
        sage: v
        Idèle with values:
          infinity_0:   1
          (2, a):       a * U(5)
          (2, a + 1):   a * U(2)
          (3):          -1 * U(1)
          (5):          1/5 * U(1)
          other primes: 1 * U(0)
        sage: M
        (
        [ 1/5 mod 12    6 mod 24]
        [   9 mod 12 16/5 mod 12], 2/25
        )

    Or output precision `1000`::

        sage: v, M = shimura_connecting_homomorphism(u, 1000)
        sage: v
        Idèle with values:
          infinity_0:   1
          (2, a):       a * U(6)
          (2, a + 1):   a * U(3)
          (3):          -1 * U(1)
          (5):          1/5 * U(4)
          other primes: 1 * U(0)
        sage: M
        (
        [7501/5 mod 3000    750 mod 6000]
        [  2625 mod 3000 9376/5 mod 3000], 2/25
        )
    """
    if u.has_exact_finite_part():
        raise NotImplementedError("not implemented for idèles having exact finite part")

    # First we convert u to a vector of profinite QQ-numbers.
    K = u.parent().number_field()
    a = Adeles(K)(u)
    t, s = a.finite_part().to_rational_vector()

    # Next we compute the entries of the transpose of the matrix
    # representing the multiplication by x map.
    theta = K.gen()
    C, B, _ = theta.minpoly().list()
    E = matrix(Qhat, [[t-B*s, -C*s], [s, t]])

    # Lastly we compute the valuations of the determinant of the exact
    # matrix as a rational number Delta.
    Delta = prod([P.norm()**u.valuation(P) for P in u.stored_primes()])

    if output_prec is None:
        return E, Delta

    # We make a copy of u as to not change u itself.
    v = Ideles(K)(u)

    # We avoid that output_prec is a Python int.
    output_prec = ZZ(output_prec)

    while modulus(E) / output_prec not in ZZ:
        for p in (modulus(E) / output_prec).denominator().prime_divisors():
            increment = output_prec.valuation(p) - modulus(E).valuation(p)
            v.increase_precision(p, increment)
        E, Delta = shimura_connecting_homomorphism(v)

    return v, (E, Delta)

def factored_shimura_connecting_homomorphism(u, output_prec):
    r"""
    Evaluate Shimura's connecting homomorphism at the idèle ``u`` and factor
    the result into a matrix in `GL_2(\hat{\ZZ})` and a matrix in `GL_2^+(\QQ)`

    INPUT:

    - ``u`` -- a `K`-idèle for some imaginary quadratic number field `K` whose
      ring of integers is generated by ``K.gen()``; the point to evaluate the
      homomorphism in
    - ``output_prec`` -- a positive integer; the desired output precision

    OUTPUT:

    A pair `(B, A)` where `B` is an integral `2 \times 2`-matrix over the ring
    of profinite `\QQ`-numbers with precision (i.e. modulus) divisible by
    ``output_prec`` and `A \in GL_2^+(\QQ)` such that for some `x \in \hat{K}^*`
    that ``u`` represents `g(x)A^{-1}` is represented by `B`.

    ALGORITHM:

    We perform Algorithm 9.2 of [Her2021]

    EXAMPLES:

    We create an imaginary quadratic number field whose generator also generates
    the ring of integers. ::

        sage: K.<a> = QuadraticField(-10)
        sage: K.integral_basis()
        [1, a]
        sage: J = Ideles(K)
        sage: p2, p5 = K.ideal(2, a), K.ideal(5, a)

    We evaluate the corresponding Shimura homomorphism at some idèles. ::

        sage: u = J(-1, {p2: (a+1, 3), 3: (3, 0), p5: (-1, 4)}); u
        Idèle with values:
          infinity_0:   -1
          (2, a):       (a + 1) * U(3)
          (3):          3 * U(0)
          (5, a):       -1 * U(4)
          other primes: 1 * U(0)
        sage: factored_shimura_connecting_homomorphism(u, 10)
        (
        [133 mod 150 150 mod 300]  [3 0]
        [  15 mod 30 133 mod 150], [0 3]
        )
        sage: factored_shimura_connecting_homomorphism(u, 300)
        (
        [ 583 mod 1500 2250 mod 3000]  [3 0]
        [   75 mod 300  583 mod 1500], [0 3]
        )

    ::

        sage: v = J(3*I, {p2: (a/7, 2), p5: (a/5, 3)}); v
        Idèle with values:
          infinity_0:   3*I
          (2, a):       1/7*a * U(2)
          (5, a):       1/5*a * U(3)
          other primes: 1 * U(0)
        sage: factored_shimura_connecting_homomorphism(v, 1)
        (
        [0 mod 250 49 mod 50]  [1/5   0]
        [ 1 mod 50  0 mod 25], [  0   2]
        )
        sage: factored_shimura_connecting_homomorphism(v, 18)
        (
        [500 mod 4500  549 mod 900]  [1/5   0]
        [ 351 mod 900   50 mod 450], [  0   2]
        )
    """
    # Step 1. Get an image matrix with integral precision.
    u_1, (E_1, Delta_1) = shimura_connecting_homomorphism(u, 1)
    # Step 2. Get an image matrix with good precision.
    P_1 = Delta_1.numerator() * denominator(E_1)
    u_2, (E_2, Delta_2) = shimura_connecting_homomorphism(u_1, P_1)
    # Step 3. Factor the image matrix.
    A_0 = factor_GLQhat(E_2, Delta_2)
    # Step 4. Get an image matrix with good precision and high enough precision
    #         to obtain factor-output of precision at least ``output_prec``.
    P_2 = lcm(P_1, output_prec*A_0.inverse().denominator())
    u_3, (E_3, Delta_3) = shimura_connecting_homomorphism(u_2, P_2)
    # Step 5. Factor the image matrix.
    A = factor_GLQhat(E_3, Delta_3)
    # Step 6. Compute B and output the results.
    B = E_3 * A.inverse()
    return B, A
