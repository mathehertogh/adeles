r"""
------------------------------------------------------------------
Computing Hilbert class field using idelic Shimura reciprocity law
------------------------------------------------------------------

Below we compute the Hilbert class field of the quadratic imaginary number field
of discriminant -71 using Shimura's reciprocity law.
We will use the modular function `\gamma_2` of level 3 (TODO does this function
have a name or better description...?).
This is also done by Alice Gee and Peter Stevenhagen in [TODO].
Contrary to them, we will do the calculation using our implementation of ideles.
In order to extract an explicit action, we use ``GL2Qhat_factor()`` to factor
matrices in `GL_2(\hat{\QQ})` into a product of a matrix in `GL_2(\hat{\ZZ})`
and a matrix in `GL_2^+(\QQ)`.

We start with loading our code and initilizing our quadratic imaginary number
field together with its idele group. ::

    sage: from shimura import *
    sage: from modular import *
    sage: R = ZZ['x']; x = R.gen()
    sage: K.<theta> = NumberField(x**2+x+18)
    sage: J = IdeleGroup(K)
    sage: level = 3  # the level of our modular function gamma_2

Finding the class invariant
---------------------------

Now we want to compute our class invariant. This means finding an element
`\alpha \in H_3` that is invariant under `Gal(H_3/H)`, where `H` is the
Hilbert class field of `K` and `H_3` its ray class field modulo 3.

Write `\mathcal{O}` for the ring of integers of `K`.
The Artin map `(\mathcal{O}/3\mathcal{O})^* \to Gal(H_3/H)` is surjective with
kernel `\mathcal{O}^* = \{\pm 1\}`. Hence it suffices for `\alpha` to be
be invariant under `(\mathcal{O}/3\mathcal{O})^* / \{\pm 1\}`.
We compute::

    sage: O = K.maximal_order()
    sage: Omod3 = O.quotient_ring(3, 'b')
    sage: Omod3star = K.ideal(3).idealstar(flag=2)  # flag=2 means compute generators
    sage: Omod3star.gens_values()
    (-theta + 1, theta - 1)

Hence `(\mathcal{O}/3\mathcal{O})^* / \{\pm 1\}` is generated by `\theta-1`.
We compute the action of `\theta-1 \mod 3` on `\gamma_2` as follows;

First we create an idele out of `\theta-1 \mod 3`::

    sage: x = J(Omod3(theta-1)); x  # TODO: fix the ugly infinite place-printing below to CC^*
    ([-infinity .. +infinity] + [-infinity .. +infinity]*I, Z_p2*, Z_q2*, (theta - 1)*(1+M_p3^1), (theta - 1)*(1+M_q3^1), ...)
    where:
            p2 = Fractional ideal (2, theta)
            q2 = Fractional ideal (2, theta + 1)
            p3 = Fractional ideal (3, theta)
            q3 = Fractional ideal (3, theta + 1)

Next we compute the image of `x` under Shimura's connecting homomorphism, which
gives us a matrix in `GL_2(\ZZ/3\ZZ)`::

    sage: A = connecting_homomorphism_integral(x, level); A
    [1 0]
    [1 2]
    sage: det(A)
    2

Now we factor `A` as `\iota(d) \cdot U` with `U \in SL_2(\ZZ/3\ZZ)`,
`d = det(A)` and `\iota(d) = (1, 0; 0, d)`::

    sage: d = det(A); d
    2
    sage: U = ~iota(d) * A
    sage: iota(d), U
    (
    [1 0]  [1 0]
    [0 2], [2 1]
    )
    sage: iota(d)*U == A
    True

This tells us that `x` acts on `\zeta_3` as `\zeta_3 \mapsto \zeta_3^d =
\zeta_3^2`.
We determine the action of `x` on `\gamma_2`, which equals the action of `U` on
`\gamma_2`, using the following fact.
`SL_2(\ZZ)` (and hence `SL_2(\ZZ/3\ZZ)`) is generated by the "standard
generators" `S = (0, -1; 1, 0)` and `T = (1, 1; 0, 1)` and their action on
`\gamma_2` is given by

    - `\gamma_2^S = \gamma_2`;
    - `\gamma_2^T = \zeta_3^{-1}  \gamma_2`.

Hence we factor `U` as a product of `S`'s and `T`'s and find the explicit
action. This is done in the function below::

    sage: STs = ST_factor(U); STs
    (S^3*T^-1*S)^2
    sage: print_action_on_gamma_2(STs)
      gamma_2 ]--> zeta_3^2 * gamma_2

We see that `\zeta_3^x/\zeta_3 = \zeta_3` and `\gamma_2^x/\gamma_2 = \zeta_3^2`.
Hence `\zeta_3 \gamma_2` is left invariant by `x` and so we define `\alpha = 
\zeta_3 \gamma_2(\theta)`.
Because now by Shimura's reciprocity law, we have
`\alpha^x = (\zeta_3 \gamma_2)^x(\theta) = \zeta_3 \gamma_2(\theta) = \alpha`.

Computing the Hilbert class field
---------------------------------

We now know that `\alpha \in H` and in all likelihood, we will have `\QQ(\alpha)
= H`. So we want to compute the minimal polynomial of `\alpha` over `\QQ`.
We will do this by computing the conjugates of `\alpha` over `\QQ`.

Recall that the Hilbert class field is the ray class field modulo 1. Write
`Cl` for the ray class group modulo 1 (which is isomorphic to the class group
of `K`). The Artin map `Cl \to Gal(H/\QQ)` is an isomorphism and so the
conjugates of `\alpha` are given by `\alpha^x` for `x \in Cl`.

For each `x \in Cl` we will compute an approximation of `\alpha^x` in `\CC` as
follows. We replace `x` by its image in the idele group `J` of `K`.
Then we apply Shimura's connecting homomorphism to obtain a matrix `A \in
GL_2(\hat{\QQ})`. We use our ``GL2Qhat_factor()`` function to obtain matrices
`B \in GL_2(\hat{\ZZ})` and `M \in GL_2^+(\QQ)` such that `A = B \cdot M`.

The action of `B` on `\gamma_2` is determined as we did above. The action of `M`
is given by factional linear transformations. This gives us the exact value of
`\alpha^x`, which we evaluate numerically to obtain an appoximation in `\CC`.

From these approximations of `\alpha^x`, we can determine the minimal polynomial
`f_\QQ^\alpha = \prod_{x \in Cl} (X - \alpha^x)` of `\alpha`.

We set up our embedding `\phi: K \to \CC` and compute the group `Cl`::

    sage: prec = 100  # We do our complex calculations with 100 bits of precision
    sage: CF = ComplexField(prec=prec)
    sage: zeta3 = CF(exp(2*CF(pi)*CF(I)/3))
    sage: phi = K.embeddings(CF)[1]  # the embedding where theta has positive imaginary part
    sage: Cl = ray_class_group(K, Modulus(K.ideal(1)))

Now we compute the conjugates of `\alpha`::

    sage: conjugates = []
    sage: for a in Cl:
    ....:     y = J(a)
    ....:     d, T = action_idele(y, level)  # gamma_2^x ]--> zeta_3^d * gamma_2 \circ T
    ....:     tau = apply_fractional_linear_transformation(T, theta)
    ....:     conjugate_alpha = zeta3**d * gamma_2(phi(tau), prec)
    ....:     conjugates.append(conjugate_alpha)
    sage: conjugates
    [-6794.3278793864268700913699113 - 3.2311742677852643549664402034e-27*I,
     -0.036501034995017361360497864966 - 82.427712003227761738150494070*I,
     6.3732765567256884708225027190 - 3.4583745475524154096386135513*I,
     18.327164171482763936222950822 + 6.0318468311543925988327020435*I,
     18.327164171482763936222950826 - 6.0318468311543925988327020530*I,
     6.3732765567256884708225417027 + 3.4583745475524154096385923838*I,
     -0.036501034995017361360497840278 + 82.427712003227761738150494092*I]

And lastly we find the integral polynomial corresponding to these conjugates::

    sage: P = CF['y']; y = P.gen()
    sage: minimal_polynomial = prod([y - conjugate for conjugate in conjugates])
    sage: coefficients = [round(c.real()) + round(c.imag())*I for c in minimal_polynomial.coefficients()]
    sage: R = ZZ['X']; X = R.gen()
    sage: f = R(coefficients); f
    X^7 + 6745*X^6 - 327467*X^5 + 51857115*X^4 - 2319299751*X^3 + 41264582513*X^2 - 307873876442*X + 903568991567

We conclude that for the polynomial `f` above, we have `H = \QQ[X]/(f)`.

.. NOTE::

    The polynomial `f` above is equal to the one in [TODO], except for the sign
    at `X^3`, indicating a typo in [TODO].

.. NOTE::

    Setting the complex precision ``prec`` to low will lead to an exception at
    the very last command ``f = R(coefficients)``::

        sage: f = R(coefficients)
        Traceback (most recent call last):
        ...
        TypeError: Unable to coerce 5456*I + 903568988023 to an integer
"""



from shimura import *
from modular import *


###########################
# Phase 1. Initialization #
###########################

R = ZZ['x'];
x = R.gen()
N = ZZ(3)  # level of our modular function gamma_2
K = NumberField(x**2 + x + 18, 'theta')
theta = K.gen()
J = IdeleGroup(K)

######################################
# Phase 2. Compute a class invariant #
######################################
O = K.maximal_order()
OmodN = O.quotient_ring(N, 'b')
OmodNstar = K.ideal(N).idealstar(flag=2)  # flag=2 means compute generators
print("(O/{}O)^* is generated by {}".format(N, OmodNstar.gens_values()))

for x in OmodNstar.gens_values():
    y = J(OmodN(x))
    A = connecting_homomorphism_integral(y, N)
    d = det(A)  # A acts on zeta_N by d-th powering
    U = ~iota(d) * A  # U lies in SL_2(\ZZ/N\ZZ)
    STs = ST_factor(U)
    print("The action of {} on QQ(zeta_3, gamma_2) is given by:".format(x))
    print("  zeta_3  ]--> zeta_3^{}".format(d))
    print(STs)
    print_action_on_gamma_2(STs);

print("#################################################################")
print("# Deduce (by hand) the invarent alpha = zeta_3 * gamma_2(theta) #")
print("#################################################################")

#################################################################
# Phase 3. Compute the conjugates of our class invariant over K #
#################################################################
prec = 100  # We do our complex calculations with 100 bits of precision
CF = ComplexField(prec=prec)
zeta3 = CF(exp(2*CF(pi)*CF(I)/3))
phi = K.embeddings(CF)[1]  # the embedding where theta has positive imaginary part

conjugates = []
Cl = ray_class_group(K, Modulus(K.ideal(1))) # ray class group of modulus 1, i.e. ideal class group
for a in Cl:
    y = J(a)
    d, T = action_idele(y, N)

    tau = apply_fractional_linear_transformation(T, theta)
    conjugate_alpha = zeta3**d * gamma_2(phi(tau), prec)
    conjugates.append(conjugate_alpha)
    print("alpha^{} = {}".format(a, conjugate_alpha))

##################################################################
# Phase 4. Compute the minimal polynomial of our class invariant #
##################################################################
Cy = CF['y']; (y,) = Cy._first_ngens(1)
minimal_polynomial = prod([y - conjugate for conjugate in conjugates])
coefficients = [round(c.real()) + round(c.imag())*I for c in minimal_polynomial.coefficients()]
R = ZZ['x']; x = R.gen()
try:
    f = R(coefficients)
except TypeError:
    raise ValueError("Precision of our numerical complex computations ({} bits) is too low!".format(CF.prec()))

print("Hilbert class polynomial:")
print(f)


