

def matrix_modulus(A):
    if isinstance(A.parent().base_ring(), ProfiniteIntegers):
        return gcd([a.modulus for a in A.list()])
    return gcd([a.modulus() for a in A.list()])

def matrix_denominator(A):
    if isinstance(A.parent().base_ring(), ProfiniteIntegers):
        return 1
    return lcm([a.denominator for a in A.list()])

def is_defined_modulo(A, N):
    return gcd(N, matrix_denominator(A)) == 1 and matrix_modulus(A) / N in ZZ

def primes_missing_precision(A, N):
    """
    Compute the primes at which ``A`` needs more precision to be defined modulo
    ``N``
    """
    s = set(gcd(N, matrix_denominator(A)).prime_divisors())
    t = set((matrix_modulus(A) / N).denominator().prime_divisors())
    return s.union(t)

def matrix_modulo(A, N):
    r"""
    Project a matrix over `\hat{\ZZ}` to a matrix over `\ZZ/N\ZZ`

    INPUT:

    - ``A`` -- a matrix with entries *integral* elements of `\hat{\QQ}`
    - ``N`` -- an integer
    """
    def val(a):
        if isinstance(a, ProfiniteInteger):
            return a.value
        return a.value()
    def mod(a):
        if isinstance(a, ProfiniteInteger):
            return a.modulus
        return a.modulus()
    rows_modN = []
    for row in A:
        row_modN = []
        for a in row:
            if not N.divides(mod(a)):
                raise ValueError("not every entry of A is defined modulo {}".format(N))
            a_modN = Zmod(N)(val(a))
            row_modN.append(a_modN)
        rows_modN.append(row_modN)
    return matrix(Zmod(N), rows_modN)


def ST_factor(A, return_homomorphism=False):
    r"""
    Factor the `SL_2(\ZZ/N\ZZ)`-matrix ``A`` into the standard generators S and T

    Here we have `S = (0, -1; 1, 0)` and `T = (1, 1; 0, 1)`. Together they
    generate `SL_2(\ZZ)` and hence also `SL_2(\ZZ/N\ZZ)` for any integer `N`.

    INPUT:

    - ``A`` -- a matrix in `SL_2(\ZZ/N\ZZ)` for some integer `N`
    - ``return_homomorphism`` -- boolean (default: ``False``); whether or not to
                                 return the homomorphism `f` described below as
                                 well

    OUPUT:

    An element of the free multiplicative group G generated by `S` and `T` which
    is mapped to ``A`` by the homomorphism `f: G \to SL_2(\ZZ/N\ZZ)` that maps S
    to (0, -1; 1, 0) and T to (1, 1; 0, 1).

    If ``return_homomorphism`` is ``True``, also returns `f`.
    """
    from sage.modular.arithgroup.arithgroup_perm import sl2z_word_problem
    from sage.modular.local_comp.liftings import lift_matrix_to_sl2z
    N = A.base_ring().order()
    A_lift = SL2Z(lift_matrix_to_sl2z(A.list(), N))
    G.<S,T> = FreeGroup() # S=(0,-1;1,0), T=L=(1,1;0,1), R=(1,0;1,1)
    # We want to factor A_lift into a product of S's and T's. The function
    # sl2z_word_problem() already factors it into L's and R's for us.
    # We just do a simple remapping using the following relation:
    R = S^3 * T^-1 * S
    factorization = G.one()
    for is_R, e in sl2z_word_problem(A_lift):
        if is_R:
            factorization = factorization * R^e
        else:
            factorization = factorization * T^e
    if not return_homomorphism:
        return factorization
    M = SL(2, Zmod(N))
    Sm = M([0, -1, 1, 0])
    Tm = M([1, 1, 0, 1])
    f = Hom(G, M)([Sm, Tm])
    return factorization, f


def SUM_factor(A):
    r"""
    Compute the SUM-factorization of the `GL_2(\hat{\QQ})`-matrix ``A``

    INPUT:

    - ``A`` -- a matrix in `GL_2(\hat{\QQ})`

    OUTPUT:

    A triple (S, U, M) satisfying:
    - S*U*M == A
    - S = (1, 0; 0, d) with `d \in \hat{\ZZ}^*`
    - U in `SL_2(\hat{\ZZ})`
    - M in `GL_2^+(\QQ)`

    Increasing the precision of ``A`` at a prime `p` will ultimately increase
    the precision of the returned ``S`` and ``U`` at `p`.
    """
    Zhat = ProfiniteIntegers()
    #print(A); print()

    # Make all of A's entries integral.
    #print("# Make all of A's entries integral.")
    denominator = lcm([a.denominator for a in A.list()])
    omega = matrix(QQ, [[denominator, 0], [0, denominator]])
    A = A * omega
    M = ~omega
    A = MatrixSpace(Zhat, 2)(A)
    #A = matrix(Zhat, [[Zhat._from_profinite_number(A[0,0]), Zhat._from_profinite_number(A[0,1])], [Zhat._from_profinite_number(A[1,0]), Zhat._from_profinite_number(A[1,1])]])
    #print(A); print()

    # Create a zero at the bottom-left entry of A.
    #print("# Create a zero at the bottom-left entry of A.")
    while A[1,0].value != 0:
        if A[1,1].value.abs() < A[1,0].value.abs():
            alpha = matrix(ZZ, [[0, 1], [1, 0]])
            A = A * alpha # swap columns
            M = ~alpha * M
            #print(A); print()
            if A[1,0].value.is_zero():
                break
        scalar = A[1,1].value // A[1,0].value
        alpha = matrix(ZZ, [[1, -scalar], [0, 1]])
        A = A * alpha
        M = ~alpha * M
        #print(A); print()

    # Make top-left entry of A an element of `\hat{\ZZ}^*` (i.e. make its value
    # coprime to its modulus).
    #print(r"# Make top-left entry of A an element of `\hat{\ZZ}^*`")
    g = gcd(A[0,0].modulus, A[0,0].value)
    beta = matrix(QQ, [[1/g, 0], [0, 1]])
    # We program the statement A = A * beta ad hoc:
    A[0,0].value //= g
    A[0,0].modulus //= g
    A[1,0].value //= g
    A[1,0].modulus //= g
    M = ~beta * M
    #print(A); print()

    # Make top-right entry of A zero.
    #print("# Make top-right entry of A zero.")
    f = A[0,0].value.inverse_mod(A[0,0].modulus)
    gamma = matrix(ZZ, [[1, -f*A[0,1].value], [0, 1]])
    A = A * gamma
    M = ~gamma * M
    #print(A); print()

    # Make bottem-right entry of A an element of `\hat{\ZZ}^*` (i.e. make its
    # value coprime to its modulus).
    #print(r"# Make bottem-right entry of A an element of `\hat{\ZZ}^*`")
    g = gcd(A[1,1].modulus, A[1,1].value)
    delta = matrix(QQ, [[1, 0], [0, 1/g]])
    # We program the statement A = A * delta ad hoc:
    A[0,1].value //= g
    A[0,1].modulus //= g
    A[1,1].value //= g
    A[1,1].modulus //= g
    M = ~delta * M
    #print(A); print()

    # Make sure M has positive determinant.
    if det(M) < 0:
        epsilon = matrix(ZZ, [[1, 0], [0, -1]])
        A = A * epsilon
        M = epsilon * M # We have ~epsilon==epsilon

    # Compute S = iota(det(A)) and U, the left-over with determinant 1
    S = matrix(Zhat, [[1, 0], [0, det(A)]])
    det_inv = det(A).value.inverse_mod(det(A).modulus)
    S_inv = matrix(Zhat, [[1, 0], [0, det_inv]])
    U = S_inv * A

    return S, U, M
