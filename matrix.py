
from sage.rings.integer_ring import ZZ
from sage.rings.finite_rings.integer_mod_ring import Zmod
from sage.arith.functions import lcm
from sage.arith.misc import gcd
from sage.matrix.constructor import matrix
from sage.matrix.special import identity_matrix, block_matrix, diagonal_matrix
from sage.modular.arithgroup.congroup_sl2z import SL2Z
from sage.misc.functional import det
from sage.groups.free_group import FreeGroup
from profinite_number import Qhat

def value_matrix(M):
    r"""
    Return the value matrix of the `\hat{\QQ}`-matrix ``M``

    EXAMPLE::

        sage: M = matrix(Qhat, [[Qhat(1, 7/6), Qhat(1/3, 6)],
        ....:                   [ Qhat(0, 12),  Qhat(5, 18)]])
        sage: value_matrix(M)
        [  1 1/3]
        [  0   5]
    """
    value_rows = []
    for row in M:
        value_rows.append([entry.value() for entry in row])
    return matrix(value_rows)

def denominator_matrix(M):
    r"""
    Return the denominator matrix of the `\hat{\QQ}`-matrix ``M``

    EXAMPLE::

        sage: M = matrix(Qhat, [[Qhat(1, 7/6), Qhat(1/3, 6)],
        ....:                   [ Qhat(0, 12),  Qhat(5, 18)]])
        sage: denominator_matrix(M)
        [6 0]
        [0 3]
    """
    diagonal = []
    for column in M.columns():
        diagonal.append(lcm([entry.denominator() for entry in column]))
    return diagonal_matrix(diagonal)

def denominator(M):
    r"""
    Return the denominator of the `\hat{\QQ}`-matrix ``M``
    """
    return lcm([entry.denominator() for entry in M.list()])

def modulus(M):
    r"""
    Return the modulus (aka the precision) of the `\hat{\QQ}`-matrix ``M``
    """
    return gcd([entry.modulus() for entry in M.list()])

def matrix_modulo(A, N):
    r"""
    Project a matrix over `\hat{\ZZ}` to a matrix over `\ZZ/N\ZZ`

    INPUT:

    - ``A`` -- a matrix with entries *integral* elements of `\hat{\QQ}`
    - ``N`` -- an integer
    """
    rows_modN = []
    for row in A:
        row_modN = []
        for a in row:
            if not N.divides(a.modulus()):
                raise ValueError("not every entry of A is defined modulo {}".format(N))
            a_modN = Zmod(N)(a.value())
            row_modN.append(a_modN)
        rows_modN.append(row_modN)
    return matrix(Zmod(N), rows_modN)

def ST_factor(A, return_homomorphism=False):
    r"""
    Factor the `SL_2(\ZZ/N\ZZ)`-matrix ``A`` into the standard generators S and T

    Here we have `S = (0, -1; 1, 0)` and `T = (1, 1; 0, 1)`. Together they
    generate `SL_2(\ZZ)` and hence also `SL_2(\ZZ/N\ZZ)` for any integer `N`.

    INPUT:

    - ``A`` -- a matrix in `SL_2(\ZZ/N\ZZ)` for some integer `N`
    - ``return_homomorphism`` -- boolean (default: ``False``); whether or not to
      return the homomorphism `f` described below as well

    OUPUT:

    An element of the free multiplicative group G generated by `S` and `T` which
    is mapped to ``A`` by the homomorphism `f: G \to SL_2(\ZZ/N\ZZ)` that maps S
    to (0, -1; 1, 0) and T to (1, 1; 0, 1).

    If ``return_homomorphism`` is ``True``, also returns `f`.
    """
    from sage.modular.arithgroup.arithgroup_perm import sl2z_word_problem
    from sage.modular.local_comp.liftings import lift_matrix_to_sl2z
    N = A.base_ring().order()
    A_lift = SL2Z(lift_matrix_to_sl2z(A.list(), N))
    G = FreeGroup(names=('S', 'T',)); (S, T,) = G._first_ngens(2)# S=(0,-1;1,0), T=L=(1,1;0,1), R=(1,0;1,1)
    # We want to factor A_lift into a product of S's and T's. The function
    # sl2z_word_problem() already factors it into L's and R's for us.
    # We just do a simple remapping using the following relation:
    R = S**ZZ(3)  * T**ZZ(-1)  * S
    factorization = G.one()
    for is_R, e in sl2z_word_problem(A_lift):
        if is_R:
            factorization = factorization * R**e
        else:
            factorization = factorization * T**e
    if not return_homomorphism:
        return factorization
    M = SL(2 , Zmod(N))
    Sm = M([0, -1, 1, 0])
    Tm = M([1, 1, 0, 1])
    f = Hom(G, M)([Sm, Tm])
    return factorization, f

def factor_GLQhat(M, detM):
    """
    Perform algorithm 7.4 of [Her2021]
    """
    n = M.nrows()

    # Step 1: compute the denominator matrix of M.
    D = denominator_matrix(M)

    # Step 2: construct J and compute its Hermite Normal Form A_0.
    MD = M * D
    detMD = ZZ(detM * det(D))
    detMD_I = detMD * identity_matrix(n)
    vMD = value_matrix(MD).change_ring(ZZ)
    J = block_matrix([[vMD], [detMD_I]])
    A_0 = J.hermite_form(include_zero_rows=False)

    # Step 3: ensure that the determinant of A_0 is positive.
    if det(A_0) < 0:
        A_0 = diagonal_matrix([1 for i in range(n-1)] + [-1]) * A_0

    # Step 4: compute and return A.
    A = A_0 * D.inverse()
    return A