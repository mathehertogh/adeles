r"""
In this file we will compute the Hiblert class field of the imaginary quadratic
field K of discriminant -71 using Shimura's reciprocity law.
We do this using a class invariant obtained from the modular function `\gamma_2`
of level 3.
"""

from sage.all_cmdline import *

from profinite_number import ProfiniteNumbers
from completion import completions
from adele import Adeles
from idele import IdeleGroup
from ray_class_group import Modulus, ray_class_group
from matrix import *

def iota(d):
    """
    Return the matrix (1, 0; 0, d)

    INPUT:

    - ``d`` -- a ring element
    """
    return matrix(d.parent(), [[1, 0], [0, d]])

def apply_fractional_linear_transformation(M, tau):
    r"""
    Apply the fractional linear transformation given by ``M`` to ``tau``

    INPUT:

    - ``M`` -- a matrix in `GL_2(\QQ)` with positive determinant
    - ``tau`` -- a field element

    OUTPUT:
    
    If ``M = (a, b; c, d)``, then return the element ``(a*tau+b)/(c*tau+d)``.
    """
    a, b, c, d = M.list()
    return (a*tau + b) / (c*tau + d)

def connecting_homomorphism(x, determinant=False):
    r"""
    This function implements Shimura's connecting homomorphism
    
    Let `K` be an imaginary quadratic field with ring of integers generated by
    `\theta`.
    Shimura's connecting homomorphism is the map `g:\hat{K}^* \to GL(\hat{\QQ})`
    that sends `x` to the transpose of the matrix describing the multiplication
    by `x` on the free `\hat{\QQ}`-module
    `\hat{K} = \theta \cdot \hat{\QQ} + \hat{\QQ}` with respect to the basis
    `(\theta, 1)`.

    INPUT:

    - ``x`` -- an idele over a quadratic imaginary field ``K``
    - ``determinant`` - TODO

    OUTPUT:

    The pair `(g(x), d)` where `d` is a rational number with the same valuations
    as the determinant of `g(y)`, where `y` is the exact representant idele
    stored for ``x``.
    """
    K = x.parent().number_field()
    theta = K.gen()
    Qhat = ProfiniteNumbers(QQ)
    Ak = Adeles(K)

    t, s = Ak(x).finite().to_profinite_rational_vector(enclosure=False)
    C, B, _ = theta.minpoly().coefficients()
    x_image = matrix(Qhat, [[t-B*s, -C*s], [s, t]])

    if not determinant:
        return x_image

    det = QQ(1)
    rational_primes = list(set([q.gens_two()[0] for q in x.finite()]))
    for p in rational_primes:
        # We will compute t_p, s_p \in Qp such that the value of x at
        # Kp = Qp + Qp*theta is given by t_p + s_p*theta.
        if len(K.primes_above(p)) == 1:
            x_p, _ = x.finite(K.ideal(p))
            t_p, s_p = x_p.vector()
        else:
            # TODO: This now always uses `p`-adics of precision 20.
            #       We should dynamically choose this precision to be
            #       sufficient for correct computation of te valuations.
            Y = []
            A = []
            for q, L, phi in completions(K, p):
                # q lies above p, L=Qp and phi: K --> Qp
                x_q, _ = x.finite(q)
                Y.append(phi(x_q))
                A.append([Qp(p).one(), phi(theta)])
            Y = vector(Y)
            A = matrix(Qp(p), A)
            t_p, s_p = A.solve_right(Y)
        # Now we compute the determinant of the p-th component of x_image, which
        # lies in GL_2(Qp) and is given by: [t_p-B*s_p  -C*s_p]
        #                                   [      s_p     t_p]
        det_p = t_p**2 - B*s_p*t_p + C*s_p**2
        # Now if we used enough precision in our p-adic computation (TODO), the
        # valuation of det_p is exactly correct, which we use:
        det *= p**det_p.valuation(p)

    return x_image, det

def connecting_homomorphism_integral(x, N=None):
    r"""
    Return some integral matrix which lies in the image of the ideles that ``x``
    represents under Shimura's connecting homomorphism

    See :func:`connecting_homomorphism` for information about Shimura's 
    connecting homomorphism.

    INPUT:

    - ``x`` -- an idele which is a unit at every prime (i.e. has valuation zero
      at every finite prime)
    - ``N`` -- non-zero integer (optional); if specified, we will produce an
      an image matrix whose modulus is divisible (over `\ZZ`) by ``N``.

    Note that the fact that ``x`` is a unit at every prime means that
    `x \in \hat{\mathcal{O}}^*`, whichs maps to `GL_2(\hat{\ZZ})`. So increasing
    the precision of ``x`` will ultimately lead to an integral image matrix with
    arbitrary high modulus.

    OUTPUT:

    The image matrix in `GL_2(\hat{\ZZ})`.
    `GL_2(\ZZ/N\ZZ)`.
    """
    if N is None:
        N = ZZ(1)

    J = x.parent()
    y = J(x) # We don't want to change the precision of ``x`` itself
    A = connecting_homomorphism(y)
    while not (in_GL2Zhat(A) and N.divides(matrix_modulus(A))):
        P = matrix_denominator(A) * (matrix_modulus(A)*matrix_denominator(A)/N).denominator()
        for p, e in P.factor():
            y.increase_precision(p, e)
        A = connecting_homomorphism(y)

    return A  # TODO: return A with entries in Qhat or Zhat?

def action_idele(x, N):
    r"""
    Compute the action of the idele ``x`` via Shimura's connecting homomorphism
    on a modular function `f` of level `N`

    Denote the connecting homomorphism by `g: \hat{K}^* \to GL_2(\hat{\QQ})`.

    INPUT:

    - ``x`` -- an idele over a quadratic imaginary field
    - ``N`` -- a positive integer; the level of the modular function

    OUTPUT:

    A pair `(d, T)` satisfying:
        - `d` is an integer and `0 \leq d < N`
        - `T \in GL_2^+(\QQ)`
        - `\zeta_3^g(x) = \zeta_3^d
        - `f^g(x) = f \circ T`
    """
    from sage.modular.local_comp.liftings import lift_matrix_to_sl2z
    K = x.parent().number_field()

    A, detA = connecting_homomorphism(x, determinant=True)
    B, M = GL2Qhat_factor(A, detA)

    while not (in_GL2Zhat(B) and N.divides(ZZ(matrix_modulus(B)))):
        P = matrix_denominator(B) * (matrix_modulus(B)*matrix_denominator(B)/N).denominator()
        for p, e in P.factor():
            x.increase_precision(p, e)
        A, detA = connecting_homomorphism(x, determinant=True)
        B, M = GL2Qhat_factor(A, detA)

    C = matrix_modulo(B, N)  # C lies in GL_2(\ZZ/N\ZZ)

    d = ZZ(det(C))  # x acts on zeta_N as d-th powering
    U = ~iota(det(C)) * C  # U lies in SL_2(\ZZ/N\ZZ)
    U_lift = SL2Z(lift_matrix_to_sl2z(U.list(), N))

    T = U_lift * M

    return d, T

r'''
def action_GL2ZmodN(A):
    r"""
    Compute the action of the `GL_2(\ZZ/N\ZZ)`-matrix ``A`` on `\gamma_2`

    OUPTPUT:

    A pair of integers `(d, e)` such that the action of ``A`` is given by:
        - `\zeta_3 \mapsto \zeta_3^d`
        - `\gamma_2 \mapsto \zeta_3^e \gamma_2`
    """
    U = ~iota(det(A)) * A
    d = ZZ(det(A))
    e = action_SL2ZmodN(U)
    return d, e

def action_SL2ZmodN(U):
    r"""
    Compute the action of the `SL_2(\ZZ/N\ZZ)`-matrix ``U``on gamma_2

    INPUT:

    - ``U`` -- a matrix in `SL_2(\ZZ/N\ZZ)`, where `N` is some integer divisible
      by 3 (the level of `\gamma_3`)

    OUTPUT:

    An integer `e` \in \{0, 1, 2\}` such that `\gamma_2^U = \zeta_3^e \gamma_2`.
    Here `zeta_3` is `exp(2*\pi*i/3)`.
    """
    N = U.base_ring().order()
    g = ST_factor(U)
    G = g.parent()
    # S acts trivially on gamma_2, so we are only interested in the number of
    # T's in U.
    n_Ts = sum([sign(g) for g in g.substitute(S=G.one()).Tietze()])
    # T acts as multiplication by zeta^-1 on gamma_2, so U acts as
    # multiplication by zeta^-n_Ts on gamma_2
    e = Zmod(N)(-n_Ts)
    return ZZ(e)
'''
